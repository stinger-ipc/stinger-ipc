"""
DO NOT MODIFY THIS FILE.  It is automatically generated by Stinger-IPC 0.6.10 and changes will be over-written
on the next generation.

This is the Server for the testable interface.

LICENSE: This generated code is not subject to any license restrictions from the generator itself.
TODO: Get license text from stinger file
"""

import json
import logging
import threading
import signal
from time import sleep
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone

UTC = timezone.utc

import isodate
import functools
from concurrent.futures import Future

logging.basicConfig(level=logging.DEBUG)
from pydantic import BaseModel, ValidationError
from typing import Callable, Dict, Any, Optional, List, Generic, TypeVar
from pyqttier.interface import IBrokerConnection
from pyqttier.message import Message
from stinger_python_utils.message_creator import MessageCreator
from stinger_python_utils.return_codes import (
    MethodReturnCode,
    StingerMethodException,
    ServerSerializationErrorStingerMethodException,
    ServerDeserializationErrorStingerMethodException,
    OutOfSyncStingerMethodException,
    stinger_exception_factory,
)
from .interface_types import *


from .property import TestablePropertyAccess


T = TypeVar("T")


@dataclass
class PropertyControls(Generic[T]):
    """
    Controls for a server property.  Generic[T] must be a single value or a pydantic BaseModel for multi-argument properties.
    """

    mutex = threading.RLock()
    getter: Callable[[], T]
    setter: Callable[[T], None]
    version: int = -1

    def get_value(self) -> T:
        return self.getter()

    def set_value(self, new_value: T) -> None:
        self.setter(new_value)


class TestableServer:

    def __init__(self, connection: IBrokerConnection, instance_id: str, property_access: TestablePropertyAccess):
        self._logger = logging.getLogger(f"TestableServer:{instance_id}")
        self._logger.setLevel(logging.DEBUG)
        self._logger.debug("Initializing TestableServer instance %s", instance_id)
        self._instance_id = instance_id
        self._service_advert_topic = "testable/{}/interface".format(self._instance_id)
        self._re_advertise_server_interval_seconds = 120  # every two minutes
        self._conn = connection
        self._running = True
        self._conn.add_message_callback(self._receive_message)
        self._property_read_write_integer: PropertyControls[int] = PropertyControls(getter=property_access.read_write_integer_getter, setter=property_access.read_write_integer_setter)
        self._conn.subscribe("testable/{}/property/readWriteInteger/setValue".format(self._instance_id), self._receive_read_write_integer_update_request_message)
        self._property_read_only_integer: PropertyControls[int] = PropertyControls(
            getter=property_access.read_only_integer_getter,
        )
        self._property_read_write_optional_integer: PropertyControls[int] = PropertyControls(
            getter=property_access.read_write_optional_integer_getter, setter=property_access.read_write_optional_integer_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteOptionalInteger/setValue".format(self._instance_id), self._receive_read_write_optional_integer_update_request_message)
        self._property_read_write_two_integers: PropertyControls[ReadWriteTwoIntegersProperty] = PropertyControls(
            getter=property_access.read_write_two_integers_getter, setter=property_access.read_write_two_integers_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteTwoIntegers/setValue".format(self._instance_id), self._receive_read_write_two_integers_update_request_message)
        self._property_read_only_string: PropertyControls[str] = PropertyControls(
            getter=property_access.read_only_string_getter,
        )
        self._property_read_write_string: PropertyControls[str] = PropertyControls(getter=property_access.read_write_string_getter, setter=property_access.read_write_string_setter)
        self._conn.subscribe("testable/{}/property/readWriteString/setValue".format(self._instance_id), self._receive_read_write_string_update_request_message)
        self._property_read_write_optional_string: PropertyControls[str] = PropertyControls(
            getter=property_access.read_write_optional_string_getter, setter=property_access.read_write_optional_string_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteOptionalString/setValue".format(self._instance_id), self._receive_read_write_optional_string_update_request_message)
        self._property_read_write_two_strings: PropertyControls[ReadWriteTwoStringsProperty] = PropertyControls(
            getter=property_access.read_write_two_strings_getter, setter=property_access.read_write_two_strings_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteTwoStrings/setValue".format(self._instance_id), self._receive_read_write_two_strings_update_request_message)
        self._property_read_write_struct: PropertyControls[AllTypes] = PropertyControls(getter=property_access.read_write_struct_getter, setter=property_access.read_write_struct_setter)
        self._conn.subscribe("testable/{}/property/readWriteStruct/setValue".format(self._instance_id), self._receive_read_write_struct_update_request_message)
        self._property_read_write_optional_struct: PropertyControls[AllTypes] = PropertyControls(
            getter=property_access.read_write_optional_struct_getter, setter=property_access.read_write_optional_struct_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteOptionalStruct/setValue".format(self._instance_id), self._receive_read_write_optional_struct_update_request_message)
        self._property_read_write_two_structs: PropertyControls[ReadWriteTwoStructsProperty] = PropertyControls(
            getter=property_access.read_write_two_structs_getter, setter=property_access.read_write_two_structs_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteTwoStructs/setValue".format(self._instance_id), self._receive_read_write_two_structs_update_request_message)
        self._property_read_only_enum: PropertyControls[Numbers] = PropertyControls(
            getter=property_access.read_only_enum_getter,
        )
        self._property_read_write_enum: PropertyControls[Numbers] = PropertyControls(getter=property_access.read_write_enum_getter, setter=property_access.read_write_enum_setter)
        self._conn.subscribe("testable/{}/property/readWriteEnum/setValue".format(self._instance_id), self._receive_read_write_enum_update_request_message)
        self._property_read_write_optional_enum: PropertyControls[Numbers] = PropertyControls(
            getter=property_access.read_write_optional_enum_getter, setter=property_access.read_write_optional_enum_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteOptionalEnum/setValue".format(self._instance_id), self._receive_read_write_optional_enum_update_request_message)
        self._property_read_write_two_enums: PropertyControls[ReadWriteTwoEnumsProperty] = PropertyControls(
            getter=property_access.read_write_two_enums_getter, setter=property_access.read_write_two_enums_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteTwoEnums/setValue".format(self._instance_id), self._receive_read_write_two_enums_update_request_message)
        self._property_read_write_datetime: PropertyControls[datetime] = PropertyControls(getter=property_access.read_write_datetime_getter, setter=property_access.read_write_datetime_setter)
        self._conn.subscribe("testable/{}/property/readWriteDatetime/setValue".format(self._instance_id), self._receive_read_write_datetime_update_request_message)
        self._property_read_write_optional_datetime: PropertyControls[datetime] = PropertyControls(
            getter=property_access.read_write_optional_datetime_getter, setter=property_access.read_write_optional_datetime_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteOptionalDatetime/setValue".format(self._instance_id), self._receive_read_write_optional_datetime_update_request_message)
        self._property_read_write_two_datetimes: PropertyControls[ReadWriteTwoDatetimesProperty] = PropertyControls(
            getter=property_access.read_write_two_datetimes_getter, setter=property_access.read_write_two_datetimes_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteTwoDatetimes/setValue".format(self._instance_id), self._receive_read_write_two_datetimes_update_request_message)
        self._property_read_write_duration: PropertyControls[timedelta] = PropertyControls(getter=property_access.read_write_duration_getter, setter=property_access.read_write_duration_setter)
        self._conn.subscribe("testable/{}/property/readWriteDuration/setValue".format(self._instance_id), self._receive_read_write_duration_update_request_message)
        self._property_read_write_optional_duration: PropertyControls[timedelta] = PropertyControls(
            getter=property_access.read_write_optional_duration_getter, setter=property_access.read_write_optional_duration_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteOptionalDuration/setValue".format(self._instance_id), self._receive_read_write_optional_duration_update_request_message)
        self._property_read_write_two_durations: PropertyControls[ReadWriteTwoDurationsProperty] = PropertyControls(
            getter=property_access.read_write_two_durations_getter, setter=property_access.read_write_two_durations_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteTwoDurations/setValue".format(self._instance_id), self._receive_read_write_two_durations_update_request_message)
        self._property_read_write_binary: PropertyControls[bytes] = PropertyControls(getter=property_access.read_write_binary_getter, setter=property_access.read_write_binary_setter)
        self._conn.subscribe("testable/{}/property/readWriteBinary/setValue".format(self._instance_id), self._receive_read_write_binary_update_request_message)
        self._property_read_write_optional_binary: PropertyControls[bytes] = PropertyControls(
            getter=property_access.read_write_optional_binary_getter, setter=property_access.read_write_optional_binary_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteOptionalBinary/setValue".format(self._instance_id), self._receive_read_write_optional_binary_update_request_message)
        self._property_read_write_two_binaries: PropertyControls[ReadWriteTwoBinariesProperty] = PropertyControls(
            getter=property_access.read_write_two_binaries_getter, setter=property_access.read_write_two_binaries_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteTwoBinaries/setValue".format(self._instance_id), self._receive_read_write_two_binaries_update_request_message)
        self._property_read_write_list_of_strings: PropertyControls[list] = PropertyControls(
            getter=property_access.read_write_list_of_strings_getter, setter=property_access.read_write_list_of_strings_setter
        )
        self._conn.subscribe("testable/{}/property/readWriteListOfStrings/setValue".format(self._instance_id), self._receive_read_write_list_of_strings_update_request_message)
        self._property_read_write_lists: PropertyControls[ReadWriteListsProperty] = PropertyControls(getter=property_access.read_write_lists_getter, setter=property_access.read_write_lists_setter)
        self._conn.subscribe("testable/{}/property/readWriteLists/setValue".format(self._instance_id), self._receive_read_write_lists_update_request_message)

        self._conn.subscribe("testable/{}/method/callWithNothing".format(self._instance_id), self._process_call_with_nothing_call)
        self._method_call_with_nothing_handler = None  # type: Optional[Callable[[], None]]

        self._conn.subscribe("testable/{}/method/callOneInteger".format(self._instance_id), self._process_call_one_integer_call)
        self._method_call_one_integer_handler = None  # type: Optional[Callable[[int], int]]

        self._conn.subscribe("testable/{}/method/callOptionalInteger".format(self._instance_id), self._process_call_optional_integer_call)
        self._method_call_optional_integer_handler = None  # type: Optional[Callable[[Optional[int]], Optional[int]]]

        self._conn.subscribe("testable/{}/method/callThreeIntegers".format(self._instance_id), self._process_call_three_integers_call)
        self._method_call_three_integers_handler = None  # type: Optional[Callable[[int, int, Optional[int]], CallThreeIntegersMethodResponse]]

        self._conn.subscribe("testable/{}/method/callOneString".format(self._instance_id), self._process_call_one_string_call)
        self._method_call_one_string_handler = None  # type: Optional[Callable[[str], str]]

        self._conn.subscribe("testable/{}/method/callOptionalString".format(self._instance_id), self._process_call_optional_string_call)
        self._method_call_optional_string_handler = None  # type: Optional[Callable[[Optional[str]], Optional[str]]]

        self._conn.subscribe("testable/{}/method/callThreeStrings".format(self._instance_id), self._process_call_three_strings_call)
        self._method_call_three_strings_handler = None  # type: Optional[Callable[[str, Optional[str], str], CallThreeStringsMethodResponse]]

        self._conn.subscribe("testable/{}/method/callOneEnum".format(self._instance_id), self._process_call_one_enum_call)
        self._method_call_one_enum_handler = None  # type: Optional[Callable[[Numbers], Numbers]]

        self._conn.subscribe("testable/{}/method/callOptionalEnum".format(self._instance_id), self._process_call_optional_enum_call)
        self._method_call_optional_enum_handler = None  # type: Optional[Callable[[Optional[Numbers]], Optional[Numbers]]]

        self._conn.subscribe("testable/{}/method/callThreeEnums".format(self._instance_id), self._process_call_three_enums_call)
        self._method_call_three_enums_handler = None  # type: Optional[Callable[[Numbers, Numbers, Optional[Numbers]], CallThreeEnumsMethodResponse]]

        self._conn.subscribe("testable/{}/method/callOneStruct".format(self._instance_id), self._process_call_one_struct_call)
        self._method_call_one_struct_handler = None  # type: Optional[Callable[[AllTypes], AllTypes]]

        self._conn.subscribe("testable/{}/method/callOptionalStruct".format(self._instance_id), self._process_call_optional_struct_call)
        self._method_call_optional_struct_handler = None  # type: Optional[Callable[[AllTypes], AllTypes]]

        self._conn.subscribe("testable/{}/method/callThreeStructs".format(self._instance_id), self._process_call_three_structs_call)
        self._method_call_three_structs_handler = None  # type: Optional[Callable[[AllTypes, AllTypes, AllTypes], CallThreeStructsMethodResponse]]

        self._conn.subscribe("testable/{}/method/callOneDateTime".format(self._instance_id), self._process_call_one_date_time_call)
        self._method_call_one_date_time_handler = None  # type: Optional[Callable[[datetime], datetime]]

        self._conn.subscribe("testable/{}/method/callOptionalDateTime".format(self._instance_id), self._process_call_optional_date_time_call)
        self._method_call_optional_date_time_handler = None  # type: Optional[Callable[[Optional[datetime]], Optional[datetime]]]

        self._conn.subscribe("testable/{}/method/callThreeDateTimes".format(self._instance_id), self._process_call_three_date_times_call)
        self._method_call_three_date_times_handler = None  # type: Optional[Callable[[datetime, datetime, Optional[datetime]], CallThreeDateTimesMethodResponse]]

        self._conn.subscribe("testable/{}/method/callOneDuration".format(self._instance_id), self._process_call_one_duration_call)
        self._method_call_one_duration_handler = None  # type: Optional[Callable[[timedelta], timedelta]]

        self._conn.subscribe("testable/{}/method/callOptionalDuration".format(self._instance_id), self._process_call_optional_duration_call)
        self._method_call_optional_duration_handler = None  # type: Optional[Callable[[Optional[timedelta]], Optional[timedelta]]]

        self._conn.subscribe("testable/{}/method/callThreeDurations".format(self._instance_id), self._process_call_three_durations_call)
        self._method_call_three_durations_handler = None  # type: Optional[Callable[[timedelta, timedelta, Optional[timedelta]], CallThreeDurationsMethodResponse]]

        self._conn.subscribe("testable/{}/method/callOneBinary".format(self._instance_id), self._process_call_one_binary_call)
        self._method_call_one_binary_handler = None  # type: Optional[Callable[[bytes], bytes]]

        self._conn.subscribe("testable/{}/method/callOptionalBinary".format(self._instance_id), self._process_call_optional_binary_call)
        self._method_call_optional_binary_handler = None  # type: Optional[Callable[[bytes], bytes]]

        self._conn.subscribe("testable/{}/method/callThreeBinaries".format(self._instance_id), self._process_call_three_binaries_call)
        self._method_call_three_binaries_handler = None  # type: Optional[Callable[[bytes, bytes, bytes], CallThreeBinariesMethodResponse]]

        self._conn.subscribe("testable/{}/method/callOneListOfIntegers".format(self._instance_id), self._process_call_one_list_of_integers_call)
        self._method_call_one_list_of_integers_handler = None  # type: Optional[Callable[[List[int]], List[int]]]

        self._conn.subscribe("testable/{}/method/callOptionalListOfFloats".format(self._instance_id), self._process_call_optional_list_of_floats_call)
        self._method_call_optional_list_of_floats_handler = None  # type: Optional[Callable[[List[float]], List[float]]]

        self._conn.subscribe("testable/{}/method/callTwoLists".format(self._instance_id), self._process_call_two_lists_call)
        self._method_call_two_lists_handler = None  # type: Optional[Callable[[List[Numbers], List[str]], CallTwoListsMethodResponse]]

        self._publish_all_properties()
        signal.signal(signal.SIGTERM, self._signal_handler)

        self._logger.debug("Starting interface advertisement thread")
        self._advertise_thread = threading.Thread(target=self._loop_publishing_interface_info, daemon=True)
        self._advertise_thread.start()

    def __del__(self):
        self.shutdown()

    def _signal_handler(self, signum, frame):
        self.shutdown()

    def shutdown(self, timeout: float = 5.0):
        """Gracefully shutdown the server and stop the advertisement thread."""
        if not self._running:
            return
        self._running = False
        self._conn.unpublish_retained(self._service_advert_topic)
        if hasattr(self, "_advertise_thread") and self._advertise_thread.is_alive():
            self._advertise_thread.join(timeout=timeout)

    @property
    def instance_id(self) -> str:
        """The instance ID of this server instance."""
        return self._instance_id

    def _loop_publishing_interface_info(self):
        """We have a discovery topic separate from the MQTT client discovery topic.
        We publish it periodically, but with a Message Expiry interval."""
        while self._running:
            if self._conn.is_connected():
                self.publish_interface_info()
                time_left = self._re_advertise_server_interval_seconds
                while self._running and time_left > 0:
                    sleep(4)
                    time_left -= 4
            else:
                sleep(2)

    def publish_interface_info(self):
        """Publishes the interface info message to the interface info topic with an expiry interval."""
        data = InterfaceInfo(instance=self._instance_id, connection_topic=(self._conn.online_topic or ""), timestamp=datetime.now(UTC).isoformat())
        expiry = int(self._re_advertise_server_interval_seconds * 1.2)  # slightly longer than the re-advertise interval
        topic = self._service_advert_topic
        self._logger.debug("Publishing interface info to %s: %s", topic, data.model_dump_json(by_alias=True))
        msg = MessageCreator.status_message(topic, data, expiry)
        self._conn.publish(msg)

    def publish_read_write_integer_value(self, *_, **__):
        """Publishes the current value of the 'read_write_integer' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_integer.mutex:
            self._property_read_write_integer.version += 1
            read_write_integer_prop_obj = ReadWriteIntegerProperty(value=self._property_read_write_integer.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteInteger/value".format(self._instance_id), read_write_integer_prop_obj, self._property_read_write_integer.version
            )
            self._conn.publish(state_msg)

    def publish_read_only_integer_value(self, *_, **__):
        """Publishes the current value of the 'read_only_integer' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_only_integer.mutex:
            self._property_read_only_integer.version += 1
            read_only_integer_prop_obj = ReadOnlyIntegerProperty(value=self._property_read_only_integer.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readOnlyInteger/value".format(self._instance_id), read_only_integer_prop_obj, self._property_read_only_integer.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_optional_integer_value(self, *_, **__):
        """Publishes the current value of the 'read_write_optional_integer' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_optional_integer.mutex:
            self._property_read_write_optional_integer.version += 1
            read_write_optional_integer_prop_obj = ReadWriteOptionalIntegerProperty(value=self._property_read_write_optional_integer.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteOptionalInteger/value".format(self._instance_id), read_write_optional_integer_prop_obj, self._property_read_write_optional_integer.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_two_integers_value(self, *_, **__):
        """Publishes the current value of the 'read_write_two_integers' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_two_integers.mutex:
            self._property_read_write_two_integers.version += 1
            read_write_two_integers_prop_obj = self._property_read_write_two_integers.get_value()
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteTwoIntegers/value".format(self._instance_id), read_write_two_integers_prop_obj, self._property_read_write_two_integers.version
            )
            self._conn.publish(state_msg)

    def publish_read_only_string_value(self, *_, **__):
        """Publishes the current value of the 'read_only_string' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_only_string.mutex:
            self._property_read_only_string.version += 1
            read_only_string_prop_obj = ReadOnlyStringProperty(value=self._property_read_only_string.get_value())
            state_msg = MessageCreator.property_state_message("testable/{}/property/readOnlyString/value".format(self._instance_id), read_only_string_prop_obj, self._property_read_only_string.version)
            self._conn.publish(state_msg)

    def publish_read_write_string_value(self, *_, **__):
        """Publishes the current value of the 'read_write_string' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_string.mutex:
            self._property_read_write_string.version += 1
            read_write_string_prop_obj = ReadWriteStringProperty(value=self._property_read_write_string.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteString/value".format(self._instance_id), read_write_string_prop_obj, self._property_read_write_string.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_optional_string_value(self, *_, **__):
        """Publishes the current value of the 'read_write_optional_string' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_optional_string.mutex:
            self._property_read_write_optional_string.version += 1
            read_write_optional_string_prop_obj = ReadWriteOptionalStringProperty(value=self._property_read_write_optional_string.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteOptionalString/value".format(self._instance_id), read_write_optional_string_prop_obj, self._property_read_write_optional_string.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_two_strings_value(self, *_, **__):
        """Publishes the current value of the 'read_write_two_strings' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_two_strings.mutex:
            self._property_read_write_two_strings.version += 1
            read_write_two_strings_prop_obj = self._property_read_write_two_strings.get_value()
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteTwoStrings/value".format(self._instance_id), read_write_two_strings_prop_obj, self._property_read_write_two_strings.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_struct_value(self, *_, **__):
        """Publishes the current value of the 'read_write_struct' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_struct.mutex:
            self._property_read_write_struct.version += 1
            read_write_struct_prop_obj = ReadWriteStructProperty(value=self._property_read_write_struct.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteStruct/value".format(self._instance_id), read_write_struct_prop_obj, self._property_read_write_struct.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_optional_struct_value(self, *_, **__):
        """Publishes the current value of the 'read_write_optional_struct' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_optional_struct.mutex:
            self._property_read_write_optional_struct.version += 1
            read_write_optional_struct_prop_obj = ReadWriteOptionalStructProperty(value=self._property_read_write_optional_struct.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteOptionalStruct/value".format(self._instance_id), read_write_optional_struct_prop_obj, self._property_read_write_optional_struct.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_two_structs_value(self, *_, **__):
        """Publishes the current value of the 'read_write_two_structs' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_two_structs.mutex:
            self._property_read_write_two_structs.version += 1
            read_write_two_structs_prop_obj = self._property_read_write_two_structs.get_value()
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteTwoStructs/value".format(self._instance_id), read_write_two_structs_prop_obj, self._property_read_write_two_structs.version
            )
            self._conn.publish(state_msg)

    def publish_read_only_enum_value(self, *_, **__):
        """Publishes the current value of the 'read_only_enum' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_only_enum.mutex:
            self._property_read_only_enum.version += 1
            read_only_enum_prop_obj = ReadOnlyEnumProperty(value=self._property_read_only_enum.get_value())
            state_msg = MessageCreator.property_state_message("testable/{}/property/readOnlyEnum/value".format(self._instance_id), read_only_enum_prop_obj, self._property_read_only_enum.version)
            self._conn.publish(state_msg)

    def publish_read_write_enum_value(self, *_, **__):
        """Publishes the current value of the 'read_write_enum' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_enum.mutex:
            self._property_read_write_enum.version += 1
            read_write_enum_prop_obj = ReadWriteEnumProperty(value=self._property_read_write_enum.get_value())
            state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteEnum/value".format(self._instance_id), read_write_enum_prop_obj, self._property_read_write_enum.version)
            self._conn.publish(state_msg)

    def publish_read_write_optional_enum_value(self, *_, **__):
        """Publishes the current value of the 'read_write_optional_enum' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_optional_enum.mutex:
            self._property_read_write_optional_enum.version += 1
            read_write_optional_enum_prop_obj = ReadWriteOptionalEnumProperty(value=self._property_read_write_optional_enum.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteOptionalEnum/value".format(self._instance_id), read_write_optional_enum_prop_obj, self._property_read_write_optional_enum.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_two_enums_value(self, *_, **__):
        """Publishes the current value of the 'read_write_two_enums' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_two_enums.mutex:
            self._property_read_write_two_enums.version += 1
            read_write_two_enums_prop_obj = self._property_read_write_two_enums.get_value()
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteTwoEnums/value".format(self._instance_id), read_write_two_enums_prop_obj, self._property_read_write_two_enums.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_datetime_value(self, *_, **__):
        """Publishes the current value of the 'read_write_datetime' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_datetime.mutex:
            self._property_read_write_datetime.version += 1
            read_write_datetime_prop_obj = ReadWriteDatetimeProperty(value=self._property_read_write_datetime.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteDatetime/value".format(self._instance_id), read_write_datetime_prop_obj, self._property_read_write_datetime.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_optional_datetime_value(self, *_, **__):
        """Publishes the current value of the 'read_write_optional_datetime' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_optional_datetime.mutex:
            self._property_read_write_optional_datetime.version += 1
            read_write_optional_datetime_prop_obj = ReadWriteOptionalDatetimeProperty(value=self._property_read_write_optional_datetime.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteOptionalDatetime/value".format(self._instance_id), read_write_optional_datetime_prop_obj, self._property_read_write_optional_datetime.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_two_datetimes_value(self, *_, **__):
        """Publishes the current value of the 'read_write_two_datetimes' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_two_datetimes.mutex:
            self._property_read_write_two_datetimes.version += 1
            read_write_two_datetimes_prop_obj = self._property_read_write_two_datetimes.get_value()
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteTwoDatetimes/value".format(self._instance_id), read_write_two_datetimes_prop_obj, self._property_read_write_two_datetimes.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_duration_value(self, *_, **__):
        """Publishes the current value of the 'read_write_duration' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_duration.mutex:
            self._property_read_write_duration.version += 1
            read_write_duration_prop_obj = ReadWriteDurationProperty(value=self._property_read_write_duration.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteDuration/value".format(self._instance_id), read_write_duration_prop_obj, self._property_read_write_duration.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_optional_duration_value(self, *_, **__):
        """Publishes the current value of the 'read_write_optional_duration' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_optional_duration.mutex:
            self._property_read_write_optional_duration.version += 1
            read_write_optional_duration_prop_obj = ReadWriteOptionalDurationProperty(value=self._property_read_write_optional_duration.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteOptionalDuration/value".format(self._instance_id), read_write_optional_duration_prop_obj, self._property_read_write_optional_duration.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_two_durations_value(self, *_, **__):
        """Publishes the current value of the 'read_write_two_durations' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_two_durations.mutex:
            self._property_read_write_two_durations.version += 1
            read_write_two_durations_prop_obj = self._property_read_write_two_durations.get_value()
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteTwoDurations/value".format(self._instance_id), read_write_two_durations_prop_obj, self._property_read_write_two_durations.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_binary_value(self, *_, **__):
        """Publishes the current value of the 'read_write_binary' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_binary.mutex:
            self._property_read_write_binary.version += 1
            read_write_binary_prop_obj = ReadWriteBinaryProperty(value=self._property_read_write_binary.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteBinary/value".format(self._instance_id), read_write_binary_prop_obj, self._property_read_write_binary.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_optional_binary_value(self, *_, **__):
        """Publishes the current value of the 'read_write_optional_binary' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_optional_binary.mutex:
            self._property_read_write_optional_binary.version += 1
            read_write_optional_binary_prop_obj = ReadWriteOptionalBinaryProperty(value=self._property_read_write_optional_binary.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteOptionalBinary/value".format(self._instance_id), read_write_optional_binary_prop_obj, self._property_read_write_optional_binary.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_two_binaries_value(self, *_, **__):
        """Publishes the current value of the 'read_write_two_binaries' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_two_binaries.mutex:
            self._property_read_write_two_binaries.version += 1
            read_write_two_binaries_prop_obj = self._property_read_write_two_binaries.get_value()
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteTwoBinaries/value".format(self._instance_id), read_write_two_binaries_prop_obj, self._property_read_write_two_binaries.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_list_of_strings_value(self, *_, **__):
        """Publishes the current value of the 'read_write_list_of_strings' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_list_of_strings.mutex:
            self._property_read_write_list_of_strings.version += 1
            read_write_list_of_strings_prop_obj = ReadWriteListOfStringsProperty(value=self._property_read_write_list_of_strings.get_value())
            state_msg = MessageCreator.property_state_message(
                "testable/{}/property/readWriteListOfStrings/value".format(self._instance_id), read_write_list_of_strings_prop_obj, self._property_read_write_list_of_strings.version
            )
            self._conn.publish(state_msg)

    def publish_read_write_lists_value(self, *_, **__):
        """Publishes the current value of the 'read_write_lists' property.

        Accepts unused args and kwargs to make this a usable callback for application code.

        """
        with self._property_read_write_lists.mutex:
            self._property_read_write_lists.version += 1
            read_write_lists_prop_obj = self._property_read_write_lists.get_value()
            state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteLists/value".format(self._instance_id), read_write_lists_prop_obj, self._property_read_write_lists.version)
            self._conn.publish(state_msg)

    def _publish_all_properties(self):
        """Publishes the current value of all properties."""
        self.publish_read_write_integer_value()
        self.publish_read_only_integer_value()
        self.publish_read_write_optional_integer_value()
        self.publish_read_write_two_integers_value()
        self.publish_read_only_string_value()
        self.publish_read_write_string_value()
        self.publish_read_write_optional_string_value()
        self.publish_read_write_two_strings_value()
        self.publish_read_write_struct_value()
        self.publish_read_write_optional_struct_value()
        self.publish_read_write_two_structs_value()
        self.publish_read_only_enum_value()
        self.publish_read_write_enum_value()
        self.publish_read_write_optional_enum_value()
        self.publish_read_write_two_enums_value()
        self.publish_read_write_datetime_value()
        self.publish_read_write_optional_datetime_value()
        self.publish_read_write_two_datetimes_value()
        self.publish_read_write_duration_value()
        self.publish_read_write_optional_duration_value()
        self.publish_read_write_two_durations_value()
        self.publish_read_write_binary_value()
        self.publish_read_write_optional_binary_value()
        self.publish_read_write_two_binaries_value()
        self.publish_read_write_list_of_strings_value()
        self.publish_read_write_lists_value()

    def _receive_read_write_integer_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteInteger/setValue` topic
        in order to update the `read_write_integer` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_integer.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_integer.version}' of the 'read_write_integer' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_integer' property")

            recv_prop_obj = ReadWriteIntegerProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_integer.mutex:
                self._property_read_write_integer.version += 1
                self._property_read_write_integer.set_value(prop_value)

                current_prop_obj = ReadWriteIntegerProperty(value=self._property_read_write_integer.get_value())

                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteInteger/value".format(self._instance_id), current_prop_obj, self._property_read_write_integer.version)
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_integer.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteIntegerProperty(value=self._property_read_write_integer.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_integer.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_optional_integer_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteOptionalInteger/setValue` topic
        in order to update the `read_write_optional_integer` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_optional_integer.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_optional_integer.version}' of the 'read_write_optional_integer' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_optional_integer' property")

            recv_prop_obj = ReadWriteOptionalIntegerProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_optional_integer.mutex:
                self._property_read_write_optional_integer.version += 1
                self._property_read_write_optional_integer.set_value(prop_value)

                current_prop_obj = ReadWriteOptionalIntegerProperty(value=self._property_read_write_optional_integer.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalInteger/value".format(self._instance_id), current_prop_obj, self._property_read_write_optional_integer.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_optional_integer.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteOptionalIntegerProperty(value=self._property_read_write_optional_integer.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_optional_integer.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_two_integers_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteTwoIntegers/setValue` topic
        in order to update the `read_write_two_integers` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_two_integers.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_two_integers.version}' of the 'read_write_two_integers' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_two_integers' property")

            recv_prop_obj = ReadWriteTwoIntegersProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj  # type: ReadWriteTwoIntegersProperty
            with self._property_read_write_two_integers.mutex:
                self._property_read_write_two_integers.version += 1
                self._property_read_write_two_integers.set_value(prop_value)

                current_prop_obj = self._property_read_write_two_integers.get_value()  # type: ReadWriteTwoIntegersProperty

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteTwoIntegers/value".format(self._instance_id), current_prop_obj, self._property_read_write_two_integers.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_two_integers.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = self._property_read_write_two_integers.get_value()
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_two_integers.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_string_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteString/setValue` topic
        in order to update the `read_write_string` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_string.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_string.version}' of the 'read_write_string' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_string' property")

            recv_prop_obj = ReadWriteStringProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_string.mutex:
                self._property_read_write_string.version += 1
                self._property_read_write_string.set_value(prop_value)

                current_prop_obj = ReadWriteStringProperty(value=self._property_read_write_string.get_value())

                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteString/value".format(self._instance_id), current_prop_obj, self._property_read_write_string.version)
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_string.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteStringProperty(value=self._property_read_write_string.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_string.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_optional_string_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteOptionalString/setValue` topic
        in order to update the `read_write_optional_string` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_optional_string.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_optional_string.version}' of the 'read_write_optional_string' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_optional_string' property")

            recv_prop_obj = ReadWriteOptionalStringProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_optional_string.mutex:
                self._property_read_write_optional_string.version += 1
                self._property_read_write_optional_string.set_value(prop_value)

                current_prop_obj = ReadWriteOptionalStringProperty(value=self._property_read_write_optional_string.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalString/value".format(self._instance_id), current_prop_obj, self._property_read_write_optional_string.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_optional_string.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteOptionalStringProperty(value=self._property_read_write_optional_string.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_optional_string.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_two_strings_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteTwoStrings/setValue` topic
        in order to update the `read_write_two_strings` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_two_strings.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_two_strings.version}' of the 'read_write_two_strings' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_two_strings' property")

            recv_prop_obj = ReadWriteTwoStringsProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj  # type: ReadWriteTwoStringsProperty
            with self._property_read_write_two_strings.mutex:
                self._property_read_write_two_strings.version += 1
                self._property_read_write_two_strings.set_value(prop_value)

                current_prop_obj = self._property_read_write_two_strings.get_value()  # type: ReadWriteTwoStringsProperty

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteTwoStrings/value".format(self._instance_id), current_prop_obj, self._property_read_write_two_strings.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_two_strings.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = self._property_read_write_two_strings.get_value()
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_two_strings.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_struct_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteStruct/setValue` topic
        in order to update the `read_write_struct` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_struct.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_struct.version}' of the 'read_write_struct' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_struct' property")

            recv_prop_obj = ReadWriteStructProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_struct.mutex:
                self._property_read_write_struct.version += 1
                self._property_read_write_struct.set_value(prop_value)

                current_prop_obj = ReadWriteStructProperty(value=self._property_read_write_struct.get_value())

                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteStruct/value".format(self._instance_id), current_prop_obj, self._property_read_write_struct.version)
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_struct.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteStructProperty(value=self._property_read_write_struct.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_struct.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_optional_struct_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteOptionalStruct/setValue` topic
        in order to update the `read_write_optional_struct` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_optional_struct.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_optional_struct.version}' of the 'read_write_optional_struct' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_optional_struct' property")

            recv_prop_obj = ReadWriteOptionalStructProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_optional_struct.mutex:
                self._property_read_write_optional_struct.version += 1
                self._property_read_write_optional_struct.set_value(prop_value)

                current_prop_obj = ReadWriteOptionalStructProperty(value=self._property_read_write_optional_struct.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalStruct/value".format(self._instance_id), current_prop_obj, self._property_read_write_optional_struct.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_optional_struct.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteOptionalStructProperty(value=self._property_read_write_optional_struct.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_optional_struct.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_two_structs_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteTwoStructs/setValue` topic
        in order to update the `read_write_two_structs` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_two_structs.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_two_structs.version}' of the 'read_write_two_structs' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_two_structs' property")

            recv_prop_obj = ReadWriteTwoStructsProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj  # type: ReadWriteTwoStructsProperty
            with self._property_read_write_two_structs.mutex:
                self._property_read_write_two_structs.version += 1
                self._property_read_write_two_structs.set_value(prop_value)

                current_prop_obj = self._property_read_write_two_structs.get_value()  # type: ReadWriteTwoStructsProperty

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteTwoStructs/value".format(self._instance_id), current_prop_obj, self._property_read_write_two_structs.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_two_structs.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = self._property_read_write_two_structs.get_value()
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_two_structs.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_enum_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteEnum/setValue` topic
        in order to update the `read_write_enum` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_enum.version):
                raise OutOfSyncStingerMethodException(f"Request version '{prop_version}'' does not match current version '{self._property_read_write_enum.version}' of the 'read_write_enum' property")

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_enum' property")

            recv_prop_obj = ReadWriteEnumProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_enum.mutex:
                self._property_read_write_enum.version += 1
                self._property_read_write_enum.set_value(prop_value)

                current_prop_obj = ReadWriteEnumProperty(value=self._property_read_write_enum.get_value())

                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteEnum/value".format(self._instance_id), current_prop_obj, self._property_read_write_enum.version)
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_enum.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteEnumProperty(value=self._property_read_write_enum.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_enum.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_optional_enum_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteOptionalEnum/setValue` topic
        in order to update the `read_write_optional_enum` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_optional_enum.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_optional_enum.version}' of the 'read_write_optional_enum' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_optional_enum' property")

            recv_prop_obj = ReadWriteOptionalEnumProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_optional_enum.mutex:
                self._property_read_write_optional_enum.version += 1
                self._property_read_write_optional_enum.set_value(prop_value)

                current_prop_obj = ReadWriteOptionalEnumProperty(value=self._property_read_write_optional_enum.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalEnum/value".format(self._instance_id), current_prop_obj, self._property_read_write_optional_enum.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_optional_enum.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteOptionalEnumProperty(value=self._property_read_write_optional_enum.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_optional_enum.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_two_enums_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteTwoEnums/setValue` topic
        in order to update the `read_write_two_enums` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_two_enums.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_two_enums.version}' of the 'read_write_two_enums' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_two_enums' property")

            recv_prop_obj = ReadWriteTwoEnumsProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj  # type: ReadWriteTwoEnumsProperty
            with self._property_read_write_two_enums.mutex:
                self._property_read_write_two_enums.version += 1
                self._property_read_write_two_enums.set_value(prop_value)

                current_prop_obj = self._property_read_write_two_enums.get_value()  # type: ReadWriteTwoEnumsProperty

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteTwoEnums/value".format(self._instance_id), current_prop_obj, self._property_read_write_two_enums.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_two_enums.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = self._property_read_write_two_enums.get_value()
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_two_enums.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_datetime_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteDatetime/setValue` topic
        in order to update the `read_write_datetime` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_datetime.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_datetime.version}' of the 'read_write_datetime' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_datetime' property")

            recv_prop_obj = ReadWriteDatetimeProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_datetime.mutex:
                self._property_read_write_datetime.version += 1
                self._property_read_write_datetime.set_value(prop_value)

                current_prop_obj = ReadWriteDatetimeProperty(value=self._property_read_write_datetime.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteDatetime/value".format(self._instance_id), current_prop_obj, self._property_read_write_datetime.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_datetime.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteDatetimeProperty(value=self._property_read_write_datetime.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_datetime.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_optional_datetime_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteOptionalDatetime/setValue` topic
        in order to update the `read_write_optional_datetime` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_optional_datetime.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_optional_datetime.version}' of the 'read_write_optional_datetime' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_optional_datetime' property")

            recv_prop_obj = ReadWriteOptionalDatetimeProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_optional_datetime.mutex:
                self._property_read_write_optional_datetime.version += 1
                self._property_read_write_optional_datetime.set_value(prop_value)

                current_prop_obj = ReadWriteOptionalDatetimeProperty(value=self._property_read_write_optional_datetime.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalDatetime/value".format(self._instance_id), current_prop_obj, self._property_read_write_optional_datetime.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_optional_datetime.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteOptionalDatetimeProperty(value=self._property_read_write_optional_datetime.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_optional_datetime.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_two_datetimes_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteTwoDatetimes/setValue` topic
        in order to update the `read_write_two_datetimes` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_two_datetimes.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_two_datetimes.version}' of the 'read_write_two_datetimes' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_two_datetimes' property")

            recv_prop_obj = ReadWriteTwoDatetimesProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj  # type: ReadWriteTwoDatetimesProperty
            with self._property_read_write_two_datetimes.mutex:
                self._property_read_write_two_datetimes.version += 1
                self._property_read_write_two_datetimes.set_value(prop_value)

                current_prop_obj = self._property_read_write_two_datetimes.get_value()  # type: ReadWriteTwoDatetimesProperty

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteTwoDatetimes/value".format(self._instance_id), current_prop_obj, self._property_read_write_two_datetimes.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_two_datetimes.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = self._property_read_write_two_datetimes.get_value()
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_two_datetimes.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_duration_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteDuration/setValue` topic
        in order to update the `read_write_duration` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_duration.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_duration.version}' of the 'read_write_duration' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_duration' property")

            recv_prop_obj = ReadWriteDurationProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_duration.mutex:
                self._property_read_write_duration.version += 1
                self._property_read_write_duration.set_value(prop_value)

                current_prop_obj = ReadWriteDurationProperty(value=self._property_read_write_duration.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteDuration/value".format(self._instance_id), current_prop_obj, self._property_read_write_duration.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_duration.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteDurationProperty(value=self._property_read_write_duration.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_duration.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_optional_duration_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteOptionalDuration/setValue` topic
        in order to update the `read_write_optional_duration` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_optional_duration.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_optional_duration.version}' of the 'read_write_optional_duration' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_optional_duration' property")

            recv_prop_obj = ReadWriteOptionalDurationProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_optional_duration.mutex:
                self._property_read_write_optional_duration.version += 1
                self._property_read_write_optional_duration.set_value(prop_value)

                current_prop_obj = ReadWriteOptionalDurationProperty(value=self._property_read_write_optional_duration.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalDuration/value".format(self._instance_id), current_prop_obj, self._property_read_write_optional_duration.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_optional_duration.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteOptionalDurationProperty(value=self._property_read_write_optional_duration.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_optional_duration.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_two_durations_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteTwoDurations/setValue` topic
        in order to update the `read_write_two_durations` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_two_durations.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_two_durations.version}' of the 'read_write_two_durations' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_two_durations' property")

            recv_prop_obj = ReadWriteTwoDurationsProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj  # type: ReadWriteTwoDurationsProperty
            with self._property_read_write_two_durations.mutex:
                self._property_read_write_two_durations.version += 1
                self._property_read_write_two_durations.set_value(prop_value)

                current_prop_obj = self._property_read_write_two_durations.get_value()  # type: ReadWriteTwoDurationsProperty

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteTwoDurations/value".format(self._instance_id), current_prop_obj, self._property_read_write_two_durations.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_two_durations.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = self._property_read_write_two_durations.get_value()
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_two_durations.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_binary_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteBinary/setValue` topic
        in order to update the `read_write_binary` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_binary.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_binary.version}' of the 'read_write_binary' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_binary' property")

            recv_prop_obj = ReadWriteBinaryProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_binary.mutex:
                self._property_read_write_binary.version += 1
                self._property_read_write_binary.set_value(prop_value)

                current_prop_obj = ReadWriteBinaryProperty(value=self._property_read_write_binary.get_value())

                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteBinary/value".format(self._instance_id), current_prop_obj, self._property_read_write_binary.version)
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_binary.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteBinaryProperty(value=self._property_read_write_binary.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_binary.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_optional_binary_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteOptionalBinary/setValue` topic
        in order to update the `read_write_optional_binary` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_optional_binary.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_optional_binary.version}' of the 'read_write_optional_binary' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_optional_binary' property")

            recv_prop_obj = ReadWriteOptionalBinaryProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_optional_binary.mutex:
                self._property_read_write_optional_binary.version += 1
                self._property_read_write_optional_binary.set_value(prop_value)

                current_prop_obj = ReadWriteOptionalBinaryProperty(value=self._property_read_write_optional_binary.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalBinary/value".format(self._instance_id), current_prop_obj, self._property_read_write_optional_binary.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_optional_binary.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteOptionalBinaryProperty(value=self._property_read_write_optional_binary.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_optional_binary.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_two_binaries_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteTwoBinaries/setValue` topic
        in order to update the `read_write_two_binaries` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_two_binaries.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_two_binaries.version}' of the 'read_write_two_binaries' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_two_binaries' property")

            recv_prop_obj = ReadWriteTwoBinariesProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj  # type: ReadWriteTwoBinariesProperty
            with self._property_read_write_two_binaries.mutex:
                self._property_read_write_two_binaries.version += 1
                self._property_read_write_two_binaries.set_value(prop_value)

                current_prop_obj = self._property_read_write_two_binaries.get_value()  # type: ReadWriteTwoBinariesProperty

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteTwoBinaries/value".format(self._instance_id), current_prop_obj, self._property_read_write_two_binaries.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_two_binaries.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = self._property_read_write_two_binaries.get_value()
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_two_binaries.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_list_of_strings_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteListOfStrings/setValue` topic
        in order to update the `read_write_list_of_strings` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_list_of_strings.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_list_of_strings.version}' of the 'read_write_list_of_strings' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_list_of_strings' property")

            recv_prop_obj = ReadWriteListOfStringsProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj.value
            with self._property_read_write_list_of_strings.mutex:
                self._property_read_write_list_of_strings.version += 1
                self._property_read_write_list_of_strings.set_value(prop_value)

                current_prop_obj = ReadWriteListOfStringsProperty(value=self._property_read_write_list_of_strings.get_value())

                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteListOfStrings/value".format(self._instance_id), current_prop_obj, self._property_read_write_list_of_strings.version
                )
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_list_of_strings.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = ReadWriteListOfStringsProperty(value=self._property_read_write_list_of_strings.get_value())
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_list_of_strings.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_read_write_lists_update_request_message(self, message: Message):
        """When the MQTT client receives a message to the `testable/{}/property/readWriteLists/setValue` topic
        in order to update the `read_write_lists` property, this method is called to process that message
        and update the value of the property.
        """
        user_properties = message.user_properties or dict()  # type: Dict[str, str]
        prop_version_str = user_properties.get("PropertyVersion", "-1")  # type: str
        prop_version = int(prop_version_str)
        correlation_id = message.correlation_data  # type: Optional[bytes]
        response_topic = message.response_topic  # type: Optional[str]
        content_type = message.content_type  # type: Optional[str]

        try:
            if int(prop_version) != int(self._property_read_write_lists.version):
                raise OutOfSyncStingerMethodException(
                    f"Request version '{prop_version}'' does not match current version '{self._property_read_write_lists.version}' of the 'read_write_lists' property"
                )

            if content_type is None:
                self._logger.warning("No content type provided in property update for %s.  Assuming application/json.", message.topic)
                content_type = "application/json"

            if content_type != "application/json":
                raise ServerDeserializationErrorStingerMethodException(f"Unsupported content type '{content_type}' for property update of 'read_write_lists' property")

            recv_prop_obj = ReadWriteListsProperty.model_validate_json(message.payload)

            prop_value = recv_prop_obj  # type: ReadWriteListsProperty
            with self._property_read_write_lists.mutex:
                self._property_read_write_lists.version += 1
                self._property_read_write_lists.set_value(prop_value)

                current_prop_obj = self._property_read_write_lists.get_value()  # type: ReadWriteListsProperty

                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteLists/value".format(self._instance_id), current_prop_obj, self._property_read_write_lists.version)
                self._conn.publish(state_msg)

                if response_topic is not None:
                    self._logger.debug("Sending property update response for to %s", response_topic)
                    prop_resp_msg = MessageCreator.property_response_message(
                        response_topic, current_prop_obj, str(self._property_read_write_lists.version), MethodReturnCode.SUCCESS.value, correlation_id
                    )
                    self._conn.publish(prop_resp_msg)
                else:
                    self._logger.debug("No response topic provided for property update of %s", message.topic)

        except Exception as e:
            self._logger.exception("StingerMethodException while processing property update for %s: %s", message.topic, str(e))
            if response_topic is not None:
                prop_obj = self._property_read_write_lists.get_value()
                if isinstance(e, (json.JSONDecodeError, ValidationError)):
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                elif isinstance(e, StingerMethodException):
                    return_code = e.return_code
                else:
                    return_code = MethodReturnCode.SERVER_ERROR
                prop_resp_msg = MessageCreator.property_response_message(response_topic, prop_obj, str(self._property_read_write_lists.version), return_code.value, correlation_id, str(e))
                self._conn.publish(prop_resp_msg)

    def _receive_message(self, message: Message):
        """This is the callback that is called whenever any message is received on a subscribed topic."""
        self._logger.warning("Received unexpected message: %s", message)

    def emit_empty(
        self,
    ):
        """Server application code should call this method to emit the 'empty' signal.

        EmptySignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        payload = EmptySignalPayload()
        sig_msg = MessageCreator.signal_message("testable/{}/signal/empty".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_int(self, value: int):
        """Server application code should call this method to emit the 'singleInt' signal.

        SingleIntSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, int), f"The 'value' argument must be of type int, but was {type(value)}"

        payload = SingleIntSignalPayload(
            value=value,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleInt".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_optional_int(self, value: Optional[int]):
        """Server application code should call this method to emit the 'singleOptionalInt' signal.

        SingleOptionalIntSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, int) or value is None, f"The 'value' argument must be of type Optional[int], but was {type(value)}"

        payload = SingleOptionalIntSignalPayload(
            value=value if value is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleOptionalInt".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_three_integers(self, first: int, second: int, third: Optional[int]):
        """Server application code should call this method to emit the 'threeIntegers' signal.

        ThreeIntegersSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(first, int), f"The 'first' argument must be of type int, but was {type(first)}"

        assert isinstance(second, int), f"The 'second' argument must be of type int, but was {type(second)}"

        assert isinstance(third, int) or third is None, f"The 'third' argument must be of type Optional[int], but was {type(third)}"

        payload = ThreeIntegersSignalPayload(
            first=first,
            second=second,
            third=third if third is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/threeIntegers".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_string(self, value: str):
        """Server application code should call this method to emit the 'singleString' signal.

        SingleStringSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, str), f"The 'value' argument must be of type str, but was {type(value)}"

        payload = SingleStringSignalPayload(
            value=value,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleString".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_optional_string(self, value: Optional[str]):
        """Server application code should call this method to emit the 'singleOptionalString' signal.

        SingleOptionalStringSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, str) or value is None, f"The 'value' argument must be of type Optional[str], but was {type(value)}"

        payload = SingleOptionalStringSignalPayload(
            value=value if value is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleOptionalString".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_three_strings(self, first: str, second: str, third: Optional[str]):
        """Server application code should call this method to emit the 'threeStrings' signal.

        ThreeStringsSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(first, str), f"The 'first' argument must be of type str, but was {type(first)}"

        assert isinstance(second, str), f"The 'second' argument must be of type str, but was {type(second)}"

        assert isinstance(third, str) or third is None, f"The 'third' argument must be of type Optional[str], but was {type(third)}"

        payload = ThreeStringsSignalPayload(
            first=first,
            second=second,
            third=third if third is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/threeStrings".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_enum(self, value: Numbers):
        """Server application code should call this method to emit the 'singleEnum' signal.

        SingleEnumSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, Numbers), f"The 'value' argument must be of type Numbers, but was {type(value)}"

        payload = SingleEnumSignalPayload(
            value=value,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleEnum".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_optional_enum(self, value: Optional[Numbers]):
        """Server application code should call this method to emit the 'singleOptionalEnum' signal.

        SingleOptionalEnumSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, Numbers) or value is None, f"The 'value' argument must be of type Optional[Numbers], but was {type(value)}"

        payload = SingleOptionalEnumSignalPayload(
            value=value if value is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleOptionalEnum".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_three_enums(self, first: Numbers, second: Numbers, third: Optional[Numbers]):
        """Server application code should call this method to emit the 'threeEnums' signal.

        ThreeEnumsSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(first, Numbers), f"The 'first' argument must be of type Numbers, but was {type(first)}"

        assert isinstance(second, Numbers), f"The 'second' argument must be of type Numbers, but was {type(second)}"

        assert isinstance(third, Numbers) or third is None, f"The 'third' argument must be of type Optional[Numbers], but was {type(third)}"

        payload = ThreeEnumsSignalPayload(
            first=first,
            second=second,
            third=third if third is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/threeEnums".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_struct(self, value: AllTypes):
        """Server application code should call this method to emit the 'singleStruct' signal.

        SingleStructSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, AllTypes), f"The 'value' argument must be of type AllTypes, but was {type(value)}"

        payload = SingleStructSignalPayload(
            value=value,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleStruct".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_optional_struct(self, value: AllTypes):
        """Server application code should call this method to emit the 'singleOptionalStruct' signal.

        SingleOptionalStructSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, AllTypes) or value is None, f"The 'value' argument must be of type AllTypes, but was {type(value)}"

        payload = SingleOptionalStructSignalPayload(
            value=value if value is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleOptionalStruct".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_three_structs(self, first: AllTypes, second: AllTypes, third: AllTypes):
        """Server application code should call this method to emit the 'threeStructs' signal.

        ThreeStructsSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(first, AllTypes), f"The 'first' argument must be of type AllTypes, but was {type(first)}"

        assert isinstance(second, AllTypes), f"The 'second' argument must be of type AllTypes, but was {type(second)}"

        assert isinstance(third, AllTypes) or third is None, f"The 'third' argument must be of type AllTypes, but was {type(third)}"

        payload = ThreeStructsSignalPayload(
            first=first,
            second=second,
            third=third if third is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/threeStructs".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_date_time(self, value: datetime):
        """Server application code should call this method to emit the 'singleDateTime' signal.

        SingleDateTimeSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, datetime), f"The 'value' argument must be of type datetime, but was {type(value)}"

        payload = SingleDateTimeSignalPayload(
            value=value,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleDateTime".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_optional_datetime(self, value: Optional[datetime]):
        """Server application code should call this method to emit the 'singleOptionalDatetime' signal.

        SingleOptionalDatetimeSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, datetime) or value is None, f"The 'value' argument must be of type Optional[datetime], but was {type(value)}"

        payload = SingleOptionalDatetimeSignalPayload(
            value=value if value is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleOptionalDatetime".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_three_date_times(self, first: datetime, second: datetime, third: Optional[datetime]):
        """Server application code should call this method to emit the 'threeDateTimes' signal.

        ThreeDateTimesSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(first, datetime), f"The 'first' argument must be of type datetime, but was {type(first)}"

        assert isinstance(second, datetime), f"The 'second' argument must be of type datetime, but was {type(second)}"

        assert isinstance(third, datetime) or third is None, f"The 'third' argument must be of type Optional[datetime], but was {type(third)}"

        payload = ThreeDateTimesSignalPayload(
            first=first,
            second=second,
            third=third if third is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/threeDateTimes".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_duration(self, value: timedelta):
        """Server application code should call this method to emit the 'singleDuration' signal.

        SingleDurationSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, timedelta), f"The 'value' argument must be of type timedelta, but was {type(value)}"

        payload = SingleDurationSignalPayload(
            value=value,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleDuration".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_optional_duration(self, value: Optional[timedelta]):
        """Server application code should call this method to emit the 'singleOptionalDuration' signal.

        SingleOptionalDurationSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, timedelta) or value is None, f"The 'value' argument must be of type Optional[timedelta], but was {type(value)}"

        payload = SingleOptionalDurationSignalPayload(
            value=value if value is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleOptionalDuration".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_three_durations(self, first: timedelta, second: timedelta, third: Optional[timedelta]):
        """Server application code should call this method to emit the 'threeDurations' signal.

        ThreeDurationsSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(first, timedelta), f"The 'first' argument must be of type timedelta, but was {type(first)}"

        assert isinstance(second, timedelta), f"The 'second' argument must be of type timedelta, but was {type(second)}"

        assert isinstance(third, timedelta) or third is None, f"The 'third' argument must be of type Optional[timedelta], but was {type(third)}"

        payload = ThreeDurationsSignalPayload(
            first=first,
            second=second,
            third=third if third is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/threeDurations".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_binary(self, value: bytes):
        """Server application code should call this method to emit the 'singleBinary' signal.

        SingleBinarySignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, bytes), f"The 'value' argument must be of type bytes, but was {type(value)}"

        payload = SingleBinarySignalPayload(
            value=value,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleBinary".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_optional_binary(self, value: bytes):
        """Server application code should call this method to emit the 'singleOptionalBinary' signal.

        SingleOptionalBinarySignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(value, bytes) or value is None, f"The 'value' argument must be of type bytes, but was {type(value)}"

        payload = SingleOptionalBinarySignalPayload(
            value=value if value is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleOptionalBinary".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_three_binaries(self, first: bytes, second: bytes, third: bytes):
        """Server application code should call this method to emit the 'threeBinaries' signal.

        ThreeBinariesSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(first, bytes), f"The 'first' argument must be of type bytes, but was {type(first)}"

        assert isinstance(second, bytes), f"The 'second' argument must be of type bytes, but was {type(second)}"

        assert isinstance(third, bytes) or third is None, f"The 'third' argument must be of type bytes, but was {type(third)}"

        payload = ThreeBinariesSignalPayload(
            first=first,
            second=second,
            third=third if third is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/threeBinaries".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_array_of_integers(self, values: List[int]):
        """Server application code should call this method to emit the 'singleArrayOfIntegers' signal.

        SingleArrayOfIntegersSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(values, list), f"The 'values' argument must be of type List[int], but was {type(values)}"

        payload = SingleArrayOfIntegersSignalPayload(
            values=values,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleArrayOfIntegers".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_single_optional_array_of_strings(self, values: List[str]):
        """Server application code should call this method to emit the 'singleOptionalArrayOfStrings' signal.

        SingleOptionalArrayOfStringsSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(values, list) or values is None, f"The 'values' argument must be of type List[str], but was {type(values)}"

        payload = SingleOptionalArrayOfStringsSignalPayload(
            values=values if values is not None else None,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/singleOptionalArrayOfStrings".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def emit_array_of_every_type(
        self,
        first_of_integers: List[int],
        second_of_floats: List[float],
        third_of_strings: List[str],
        fourth_of_enums: List[Numbers],
        fifth_of_structs: List[Entry],
        sixth_of_datetimes: List[datetime],
        seventh_of_durations: List[timedelta],
        eighth_of_binaries: List[bytes],
    ):
        """Server application code should call this method to emit the 'arrayOfEveryType' signal.

        ArrayOfEveryTypeSignalPayload is a pydantic BaseModel which will validate the arguments.
        """

        assert isinstance(first_of_integers, list), f"The 'first_of_integers' argument must be of type List[int], but was {type(first_of_integers)}"

        assert isinstance(second_of_floats, list), f"The 'second_of_floats' argument must be of type List[float], but was {type(second_of_floats)}"

        assert isinstance(third_of_strings, list), f"The 'third_of_strings' argument must be of type List[str], but was {type(third_of_strings)}"

        assert isinstance(fourth_of_enums, list), f"The 'fourth_of_enums' argument must be of type List[Numbers], but was {type(fourth_of_enums)}"

        assert isinstance(fifth_of_structs, list), f"The 'fifth_of_structs' argument must be of type List[Entry], but was {type(fifth_of_structs)}"

        assert isinstance(sixth_of_datetimes, list), f"The 'sixth_of_datetimes' argument must be of type List[datetime], but was {type(sixth_of_datetimes)}"

        assert isinstance(seventh_of_durations, list), f"The 'seventh_of_durations' argument must be of type List[timedelta], but was {type(seventh_of_durations)}"

        assert isinstance(eighth_of_binaries, list), f"The 'eighth_of_binaries' argument must be of type List[bytes], but was {type(eighth_of_binaries)}"

        payload = ArrayOfEveryTypeSignalPayload(
            first_of_integers=first_of_integers,
            second_of_floats=second_of_floats,
            third_of_strings=third_of_strings,
            fourth_of_enums=fourth_of_enums,
            fifth_of_structs=fifth_of_structs,
            sixth_of_datetimes=sixth_of_datetimes,
            seventh_of_durations=seventh_of_durations,
            eighth_of_binaries=eighth_of_binaries,
        )
        sig_msg = MessageCreator.signal_message("testable/{}/signal/arrayOfEveryType".format(self._instance_id), payload)
        self._conn.publish(sig_msg)

    def handle_call_with_nothing(self, handler: Callable[[], None]):
        """This is a decorator to decorate a method that will handle the 'callWithNothing' method calls."""
        if self._method_call_with_nothing_handler is None and handler is not None:
            self._method_call_with_nothing_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_with_nothing_call(self, message: Message):
        """This processes a call to the 'callWithNothing' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallWithNothingMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callWithNothing: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_with_nothing_handler is not None:
            method_args = []  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                self._method_call_with_nothing_handler(*method_args)

                return_data = "{}"

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callWithNothing: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callWithNothing: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callWithNothing", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callWithNothing")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callWithNothing' method")
                self._conn.publish(err_msg)

    def handle_call_one_integer(self, handler: Callable[[int], int]):
        """This is a decorator to decorate a method that will handle the 'callOneInteger' method calls."""
        if self._method_call_one_integer_handler is None and handler is not None:
            self._method_call_one_integer_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_one_integer_call(self, message: Message):
        """This processes a call to the 'callOneInteger' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOneIntegerMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOneInteger: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_one_integer_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_one_integer_handler(*method_args)

                if not isinstance(return_values, int):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type int, but was {type(return_values)}")
                ret_obj = CallOneIntegerMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOneInteger: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOneInteger: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOneInteger", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOneInteger")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOneInteger' method")
                self._conn.publish(err_msg)

    def handle_call_optional_integer(self, handler: Callable[[Optional[int]], Optional[int]]):
        """This is a decorator to decorate a method that will handle the 'callOptionalInteger' method calls."""
        if self._method_call_optional_integer_handler is None and handler is not None:
            self._method_call_optional_integer_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_optional_integer_call(self, message: Message):
        """This processes a call to the 'callOptionalInteger' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOptionalIntegerMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOptionalInteger: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_optional_integer_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_optional_integer_handler(*method_args)

                if not isinstance(return_values, int) and return_values is not None:
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type int, but was {type(return_values)}")
                ret_obj = CallOptionalIntegerMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOptionalInteger: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOptionalInteger: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOptionalInteger", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOptionalInteger")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOptionalInteger' method")
                self._conn.publish(err_msg)

    def handle_call_three_integers(self, handler: Callable[[int, int, Optional[int]], CallThreeIntegersMethodResponse]):
        """This is a decorator to decorate a method that will handle the 'callThreeIntegers' method calls."""
        if self._method_call_three_integers_handler is None and handler is not None:
            self._method_call_three_integers_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_three_integers_call(self, message: Message):
        """This processes a call to the 'callThreeIntegers' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallThreeIntegersMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callThreeIntegers: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_three_integers_handler is not None:
            method_args = [
                payload.input1,
                payload.input2,
                payload.input3,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_three_integers_handler(*method_args)

                if not isinstance(return_values, CallThreeIntegersMethodResponse):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type CallThreeIntegersMethodResponse, but was {type(return_values)}")
                return_data = return_values

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callThreeIntegers: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callThreeIntegers: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callThreeIntegers", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callThreeIntegers")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callThreeIntegers' method")
                self._conn.publish(err_msg)

    def handle_call_one_string(self, handler: Callable[[str], str]):
        """This is a decorator to decorate a method that will handle the 'callOneString' method calls."""
        if self._method_call_one_string_handler is None and handler is not None:
            self._method_call_one_string_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_one_string_call(self, message: Message):
        """This processes a call to the 'callOneString' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOneStringMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOneString: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_one_string_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_one_string_handler(*method_args)

                if not isinstance(return_values, str):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type str, but was {type(return_values)}")
                ret_obj = CallOneStringMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOneString: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOneString: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOneString", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOneString")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOneString' method")
                self._conn.publish(err_msg)

    def handle_call_optional_string(self, handler: Callable[[Optional[str]], Optional[str]]):
        """This is a decorator to decorate a method that will handle the 'callOptionalString' method calls."""
        if self._method_call_optional_string_handler is None and handler is not None:
            self._method_call_optional_string_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_optional_string_call(self, message: Message):
        """This processes a call to the 'callOptionalString' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOptionalStringMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOptionalString: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_optional_string_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_optional_string_handler(*method_args)

                if not isinstance(return_values, str) and return_values is not None:
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type str, but was {type(return_values)}")
                ret_obj = CallOptionalStringMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOptionalString: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOptionalString: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOptionalString", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOptionalString")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOptionalString' method")
                self._conn.publish(err_msg)

    def handle_call_three_strings(self, handler: Callable[[str, Optional[str], str], CallThreeStringsMethodResponse]):
        """This is a decorator to decorate a method that will handle the 'callThreeStrings' method calls."""
        if self._method_call_three_strings_handler is None and handler is not None:
            self._method_call_three_strings_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_three_strings_call(self, message: Message):
        """This processes a call to the 'callThreeStrings' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallThreeStringsMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callThreeStrings: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_three_strings_handler is not None:
            method_args = [
                payload.input1,
                payload.input2,
                payload.input3,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_three_strings_handler(*method_args)

                if not isinstance(return_values, CallThreeStringsMethodResponse):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type CallThreeStringsMethodResponse, but was {type(return_values)}")
                return_data = return_values

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callThreeStrings: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callThreeStrings: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callThreeStrings", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callThreeStrings")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callThreeStrings' method")
                self._conn.publish(err_msg)

    def handle_call_one_enum(self, handler: Callable[[Numbers], Numbers]):
        """This is a decorator to decorate a method that will handle the 'callOneEnum' method calls."""
        if self._method_call_one_enum_handler is None and handler is not None:
            self._method_call_one_enum_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_one_enum_call(self, message: Message):
        """This processes a call to the 'callOneEnum' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOneEnumMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOneEnum: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_one_enum_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_one_enum_handler(*method_args)

                if not isinstance(return_values, Numbers):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type Numbers, but was {type(return_values)}")
                ret_obj = CallOneEnumMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOneEnum: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOneEnum: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOneEnum", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOneEnum")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOneEnum' method")
                self._conn.publish(err_msg)

    def handle_call_optional_enum(self, handler: Callable[[Optional[Numbers]], Optional[Numbers]]):
        """This is a decorator to decorate a method that will handle the 'callOptionalEnum' method calls."""
        if self._method_call_optional_enum_handler is None and handler is not None:
            self._method_call_optional_enum_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_optional_enum_call(self, message: Message):
        """This processes a call to the 'callOptionalEnum' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOptionalEnumMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOptionalEnum: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_optional_enum_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_optional_enum_handler(*method_args)

                if not isinstance(return_values, Numbers) and return_values is not None:
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type Numbers, but was {type(return_values)}")
                ret_obj = CallOptionalEnumMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOptionalEnum: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOptionalEnum: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOptionalEnum", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOptionalEnum")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOptionalEnum' method")
                self._conn.publish(err_msg)

    def handle_call_three_enums(self, handler: Callable[[Numbers, Numbers, Optional[Numbers]], CallThreeEnumsMethodResponse]):
        """This is a decorator to decorate a method that will handle the 'callThreeEnums' method calls."""
        if self._method_call_three_enums_handler is None and handler is not None:
            self._method_call_three_enums_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_three_enums_call(self, message: Message):
        """This processes a call to the 'callThreeEnums' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallThreeEnumsMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callThreeEnums: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_three_enums_handler is not None:
            method_args = [
                payload.input1,
                payload.input2,
                payload.input3,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_three_enums_handler(*method_args)

                if not isinstance(return_values, CallThreeEnumsMethodResponse):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type CallThreeEnumsMethodResponse, but was {type(return_values)}")
                return_data = return_values

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callThreeEnums: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callThreeEnums: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callThreeEnums", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callThreeEnums")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callThreeEnums' method")
                self._conn.publish(err_msg)

    def handle_call_one_struct(self, handler: Callable[[AllTypes], AllTypes]):
        """This is a decorator to decorate a method that will handle the 'callOneStruct' method calls."""
        if self._method_call_one_struct_handler is None and handler is not None:
            self._method_call_one_struct_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_one_struct_call(self, message: Message):
        """This processes a call to the 'callOneStruct' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOneStructMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOneStruct: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_one_struct_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_one_struct_handler(*method_args)

                if not isinstance(return_values, AllTypes):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type AllTypes, but was {type(return_values)}")
                ret_obj = CallOneStructMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOneStruct: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOneStruct: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOneStruct", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOneStruct")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOneStruct' method")
                self._conn.publish(err_msg)

    def handle_call_optional_struct(self, handler: Callable[[AllTypes], AllTypes]):
        """This is a decorator to decorate a method that will handle the 'callOptionalStruct' method calls."""
        if self._method_call_optional_struct_handler is None and handler is not None:
            self._method_call_optional_struct_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_optional_struct_call(self, message: Message):
        """This processes a call to the 'callOptionalStruct' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOptionalStructMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOptionalStruct: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_optional_struct_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_optional_struct_handler(*method_args)

                if not isinstance(return_values, AllTypes) and return_values is not None:
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type AllTypes, but was {type(return_values)}")
                ret_obj = CallOptionalStructMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOptionalStruct: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOptionalStruct: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOptionalStruct", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOptionalStruct")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOptionalStruct' method")
                self._conn.publish(err_msg)

    def handle_call_three_structs(self, handler: Callable[[AllTypes, AllTypes, AllTypes], CallThreeStructsMethodResponse]):
        """This is a decorator to decorate a method that will handle the 'callThreeStructs' method calls."""
        if self._method_call_three_structs_handler is None and handler is not None:
            self._method_call_three_structs_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_three_structs_call(self, message: Message):
        """This processes a call to the 'callThreeStructs' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallThreeStructsMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callThreeStructs: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_three_structs_handler is not None:
            method_args = [
                payload.input1,
                payload.input2,
                payload.input3,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_three_structs_handler(*method_args)

                if not isinstance(return_values, CallThreeStructsMethodResponse):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type CallThreeStructsMethodResponse, but was {type(return_values)}")
                return_data = return_values

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callThreeStructs: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callThreeStructs: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callThreeStructs", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callThreeStructs")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callThreeStructs' method")
                self._conn.publish(err_msg)

    def handle_call_one_date_time(self, handler: Callable[[datetime], datetime]):
        """This is a decorator to decorate a method that will handle the 'callOneDateTime' method calls."""
        if self._method_call_one_date_time_handler is None and handler is not None:
            self._method_call_one_date_time_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_one_date_time_call(self, message: Message):
        """This processes a call to the 'callOneDateTime' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOneDateTimeMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOneDateTime: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_one_date_time_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_one_date_time_handler(*method_args)

                if not isinstance(return_values, datetime):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type datetime, but was {type(return_values)}")
                ret_obj = CallOneDateTimeMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOneDateTime: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOneDateTime: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOneDateTime", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOneDateTime")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOneDateTime' method")
                self._conn.publish(err_msg)

    def handle_call_optional_date_time(self, handler: Callable[[Optional[datetime]], Optional[datetime]]):
        """This is a decorator to decorate a method that will handle the 'callOptionalDateTime' method calls."""
        if self._method_call_optional_date_time_handler is None and handler is not None:
            self._method_call_optional_date_time_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_optional_date_time_call(self, message: Message):
        """This processes a call to the 'callOptionalDateTime' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOptionalDateTimeMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOptionalDateTime: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_optional_date_time_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_optional_date_time_handler(*method_args)

                if not isinstance(return_values, datetime) and return_values is not None:
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type datetime, but was {type(return_values)}")
                ret_obj = CallOptionalDateTimeMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOptionalDateTime: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOptionalDateTime: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOptionalDateTime", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOptionalDateTime")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOptionalDateTime' method")
                self._conn.publish(err_msg)

    def handle_call_three_date_times(self, handler: Callable[[datetime, datetime, Optional[datetime]], CallThreeDateTimesMethodResponse]):
        """This is a decorator to decorate a method that will handle the 'callThreeDateTimes' method calls."""
        if self._method_call_three_date_times_handler is None and handler is not None:
            self._method_call_three_date_times_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_three_date_times_call(self, message: Message):
        """This processes a call to the 'callThreeDateTimes' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallThreeDateTimesMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callThreeDateTimes: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_three_date_times_handler is not None:
            method_args = [
                payload.input1,
                payload.input2,
                payload.input3,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_three_date_times_handler(*method_args)

                if not isinstance(return_values, CallThreeDateTimesMethodResponse):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type CallThreeDateTimesMethodResponse, but was {type(return_values)}")
                return_data = return_values

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callThreeDateTimes: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callThreeDateTimes: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callThreeDateTimes", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callThreeDateTimes")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callThreeDateTimes' method")
                self._conn.publish(err_msg)

    def handle_call_one_duration(self, handler: Callable[[timedelta], timedelta]):
        """This is a decorator to decorate a method that will handle the 'callOneDuration' method calls."""
        if self._method_call_one_duration_handler is None and handler is not None:
            self._method_call_one_duration_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_one_duration_call(self, message: Message):
        """This processes a call to the 'callOneDuration' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOneDurationMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOneDuration: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_one_duration_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_one_duration_handler(*method_args)

                if not isinstance(return_values, timedelta):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type timedelta, but was {type(return_values)}")
                ret_obj = CallOneDurationMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOneDuration: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOneDuration: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOneDuration", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOneDuration")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOneDuration' method")
                self._conn.publish(err_msg)

    def handle_call_optional_duration(self, handler: Callable[[Optional[timedelta]], Optional[timedelta]]):
        """This is a decorator to decorate a method that will handle the 'callOptionalDuration' method calls."""
        if self._method_call_optional_duration_handler is None and handler is not None:
            self._method_call_optional_duration_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_optional_duration_call(self, message: Message):
        """This processes a call to the 'callOptionalDuration' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOptionalDurationMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOptionalDuration: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_optional_duration_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_optional_duration_handler(*method_args)

                if not isinstance(return_values, timedelta) and return_values is not None:
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type timedelta, but was {type(return_values)}")
                ret_obj = CallOptionalDurationMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOptionalDuration: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOptionalDuration: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOptionalDuration", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOptionalDuration")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOptionalDuration' method")
                self._conn.publish(err_msg)

    def handle_call_three_durations(self, handler: Callable[[timedelta, timedelta, Optional[timedelta]], CallThreeDurationsMethodResponse]):
        """This is a decorator to decorate a method that will handle the 'callThreeDurations' method calls."""
        if self._method_call_three_durations_handler is None and handler is not None:
            self._method_call_three_durations_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_three_durations_call(self, message: Message):
        """This processes a call to the 'callThreeDurations' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallThreeDurationsMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callThreeDurations: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_three_durations_handler is not None:
            method_args = [
                payload.input1,
                payload.input2,
                payload.input3,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_three_durations_handler(*method_args)

                if not isinstance(return_values, CallThreeDurationsMethodResponse):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type CallThreeDurationsMethodResponse, but was {type(return_values)}")
                return_data = return_values

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callThreeDurations: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callThreeDurations: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callThreeDurations", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callThreeDurations")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callThreeDurations' method")
                self._conn.publish(err_msg)

    def handle_call_one_binary(self, handler: Callable[[bytes], bytes]):
        """This is a decorator to decorate a method that will handle the 'callOneBinary' method calls."""
        if self._method_call_one_binary_handler is None and handler is not None:
            self._method_call_one_binary_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_one_binary_call(self, message: Message):
        """This processes a call to the 'callOneBinary' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOneBinaryMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOneBinary: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_one_binary_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_one_binary_handler(*method_args)

                if not isinstance(return_values, bytes):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type bytes, but was {type(return_values)}")
                ret_obj = CallOneBinaryMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOneBinary: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOneBinary: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOneBinary", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOneBinary")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOneBinary' method")
                self._conn.publish(err_msg)

    def handle_call_optional_binary(self, handler: Callable[[bytes], bytes]):
        """This is a decorator to decorate a method that will handle the 'callOptionalBinary' method calls."""
        if self._method_call_optional_binary_handler is None and handler is not None:
            self._method_call_optional_binary_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_optional_binary_call(self, message: Message):
        """This processes a call to the 'callOptionalBinary' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOptionalBinaryMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOptionalBinary: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_optional_binary_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_optional_binary_handler(*method_args)

                if not isinstance(return_values, bytes) and return_values is not None:
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type bytes, but was {type(return_values)}")
                ret_obj = CallOptionalBinaryMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOptionalBinary: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOptionalBinary: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOptionalBinary", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOptionalBinary")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOptionalBinary' method")
                self._conn.publish(err_msg)

    def handle_call_three_binaries(self, handler: Callable[[bytes, bytes, bytes], CallThreeBinariesMethodResponse]):
        """This is a decorator to decorate a method that will handle the 'callThreeBinaries' method calls."""
        if self._method_call_three_binaries_handler is None and handler is not None:
            self._method_call_three_binaries_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_three_binaries_call(self, message: Message):
        """This processes a call to the 'callThreeBinaries' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallThreeBinariesMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callThreeBinaries: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_three_binaries_handler is not None:
            method_args = [
                payload.input1,
                payload.input2,
                payload.input3,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_three_binaries_handler(*method_args)

                if not isinstance(return_values, CallThreeBinariesMethodResponse):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type CallThreeBinariesMethodResponse, but was {type(return_values)}")
                return_data = return_values

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callThreeBinaries: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callThreeBinaries: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callThreeBinaries", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callThreeBinaries")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callThreeBinaries' method")
                self._conn.publish(err_msg)

    def handle_call_one_list_of_integers(self, handler: Callable[[List[int]], List[int]]):
        """This is a decorator to decorate a method that will handle the 'callOneListOfIntegers' method calls."""
        if self._method_call_one_list_of_integers_handler is None and handler is not None:
            self._method_call_one_list_of_integers_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_one_list_of_integers_call(self, message: Message):
        """This processes a call to the 'callOneListOfIntegers' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOneListOfIntegersMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOneListOfIntegers: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_one_list_of_integers_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_one_list_of_integers_handler(*method_args)

                if not isinstance(return_values, list):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type list, but was {type(return_values)}")
                ret_obj = CallOneListOfIntegersMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOneListOfIntegers: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOneListOfIntegers: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOneListOfIntegers", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOneListOfIntegers")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOneListOfIntegers' method")
                self._conn.publish(err_msg)

    def handle_call_optional_list_of_floats(self, handler: Callable[[List[float]], List[float]]):
        """This is a decorator to decorate a method that will handle the 'callOptionalListOfFloats' method calls."""
        if self._method_call_optional_list_of_floats_handler is None and handler is not None:
            self._method_call_optional_list_of_floats_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_optional_list_of_floats_call(self, message: Message):
        """This processes a call to the 'callOptionalListOfFloats' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallOptionalListOfFloatsMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callOptionalListOfFloats: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_optional_list_of_floats_handler is not None:
            method_args = [
                payload.input1,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_optional_list_of_floats_handler(*method_args)

                if not isinstance(return_values, list) and return_values is not None:
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type list, but was {type(return_values)}")
                ret_obj = CallOptionalListOfFloatsMethodResponse(output1=return_values)
                return_data = ret_obj

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callOptionalListOfFloats: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callOptionalListOfFloats: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callOptionalListOfFloats", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callOptionalListOfFloats")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callOptionalListOfFloats' method")
                self._conn.publish(err_msg)

    def handle_call_two_lists(self, handler: Callable[[List[Numbers], List[str]], CallTwoListsMethodResponse]):
        """This is a decorator to decorate a method that will handle the 'callTwoLists' method calls."""
        if self._method_call_two_lists_handler is None and handler is not None:
            self._method_call_two_lists_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_call_two_lists_call(self, message: Message):
        """This processes a call to the 'callTwoLists' method.  It deserializes the payload to find the method arguments,
        then calls the method handler with those arguments.  It then builds and serializes a response and publishes it to the response topic.
        """
        try:
            payload = CallTwoListsMethodRequest.model_validate_json(message.payload)
        except (json.JSONDecodeError, ValidationError) as e:
            self._logger.warning("Deserialization error while handling callTwoLists: %s", e)
            correlation_id = message.correlation_data
            response_topic = message.response_topic
            return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
            if response_topic:
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                self._conn.publish(err_msg)
            return
        correlation_id = message.correlation_data
        response_topic = message.response_topic

        if self._method_call_two_lists_handler is not None:
            method_args = [
                payload.input1,
                payload.input2,
            ]  # type: List[Any]

            return_json = ""
            debug_msg = None  # type: Optional[str]
            try:
                return_values = self._method_call_two_lists_handler(*method_args)

                if not isinstance(return_values, CallTwoListsMethodResponse):
                    raise ServerSerializationErrorStingerMethodException(f"The return value must be of type CallTwoListsMethodResponse, but was {type(return_values)}")
                return_data = return_values

            except (json.JSONDecodeError, ValidationError) as e:
                self._logger.warning("Deserialization error while handling callTwoLists: %s", e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_DESERIALIZATION_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            except StingerMethodException as sme:
                self._logger.warning("StingerMethodException while handling callTwoLists: %s", sme)
                if response_topic is not None:
                    return_code = sme.return_code
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(sme))
                    self._conn.publish(err_msg)
            except Exception as e:
                self._logger.exception("Exception while handling callTwoLists", exc_info=e)
                if response_topic is not None:
                    return_code = MethodReturnCode.SERVER_ERROR
                    err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info=str(e))
                    self._conn.publish(err_msg)
            else:
                if response_topic is not None:
                    msg = MessageCreator.response_message(response_topic, return_data, MethodReturnCode.SUCCESS.value, correlation_id)
                    self._conn.publish(msg)
        else:
            self._logger.warning("No handler registered for method callTwoLists")
            if response_topic is not None:
                return_code = MethodReturnCode.METHOD_NOT_IMPLEMENTED
                err_msg = MessageCreator.error_response_message(response_topic, return_code.value, correlation_id, debug_info="No handler registered for 'callTwoLists' method")
                self._conn.publish(err_msg)

    @property
    def read_write_integer(self) -> Optional[int]:
        """This property returns the last received (int) value for the 'read_write_integer' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_integer.get_value()

    @read_write_integer.setter
    def read_write_integer(self, value: int):
        """This property sets (publishes) a new int value for the 'read_write_integer' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, int):
            raise ValueError(f"The value must be int .")

        value_updated = False
        with self._property_read_write_integer.mutex:
            if value != self._property_read_write_integer.get_value():
                value_updated = True
                self._property_read_write_integer.set_value(value)
                self._property_read_write_integer.version += 1
                prop_obj = ReadWriteIntegerProperty(value=self._property_read_write_integer.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteInteger/value".format(self._instance_id), prop_obj, self._property_read_write_integer.version)
                self._conn.publish(state_msg)

    def set_read_write_integer(self, value: int):
        """This method sets (publishes) a new value for the 'read_write_integer' property."""
        if not isinstance(value, int):
            raise ValueError(f"The 'value' value must be int.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_integer = obj

    def on_read_write_integer_updated(self, handler: Callable[[int], None]):
        """This method registers a callback to be called whenever a new 'read_write_integer' property update is received."""
        self._property_read_write_integer.callbacks.append(handler)

    @property
    def read_only_integer(self) -> Optional[int]:
        """This property returns the last received (int) value for the 'read_only_integer' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_only_integer.get_value()

    @read_only_integer.setter
    def read_only_integer(self, value: int):
        """This property sets (publishes) a new int value for the 'read_only_integer' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, int):
            raise ValueError(f"The value must be int .")

        value_updated = False
        with self._property_read_only_integer.mutex:
            if value != self._property_read_only_integer.get_value():
                value_updated = True
                self._property_read_only_integer.set_value(value)
                self._property_read_only_integer.version += 1
                prop_obj = ReadOnlyIntegerProperty(value=self._property_read_only_integer.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readOnlyInteger/value".format(self._instance_id), prop_obj, self._property_read_only_integer.version)
                self._conn.publish(state_msg)

    def set_read_only_integer(self, value: int):
        """This method sets (publishes) a new value for the 'read_only_integer' property."""
        if not isinstance(value, int):
            raise ValueError(f"The 'value' value must be int.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_only_integer = obj

    def on_read_only_integer_updated(self, handler: Callable[[int], None]):
        """This method registers a callback to be called whenever a new 'read_only_integer' property update is received."""
        self._property_read_only_integer.callbacks.append(handler)

    @property
    def read_write_optional_integer(self) -> Optional[int]:
        """This property returns the last received (Optional[int]) value for the 'read_write_optional_integer' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_optional_integer.get_value()

    @read_write_optional_integer.setter
    def read_write_optional_integer(self, value: Optional[int]):
        """This property sets (publishes) a new Optional[int] value for the 'read_write_optional_integer' property.

        This call the setter callback into the application code to set the property value.
        """
        if (value is not None) and (not isinstance(value, int)):
            raise ValueError(f"The value must be int or None.")

        value_updated = False
        with self._property_read_write_optional_integer.mutex:
            if value != self._property_read_write_optional_integer.get_value():
                value_updated = True
                self._property_read_write_optional_integer.set_value(value)
                self._property_read_write_optional_integer.version += 1
                prop_obj = ReadWriteOptionalIntegerProperty(value=self._property_read_write_optional_integer.get_value())
                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalInteger/value".format(self._instance_id), prop_obj, self._property_read_write_optional_integer.version
                )
                self._conn.publish(state_msg)

    def set_read_write_optional_integer(self, value: Optional[int]):
        """This method sets (publishes) a new value for the 'read_write_optional_integer' property."""
        if not isinstance(value, int) and value is not None:
            raise ValueError(f"The 'value' value must be Optional[int].")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_optional_integer = obj

    def on_read_write_optional_integer_updated(self, handler: Callable[[Optional[int]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_integer' property update is received."""
        self._property_read_write_optional_integer.callbacks.append(handler)

    @property
    def read_write_two_integers(self) -> ReadWriteTwoIntegersProperty:
        """This property returns the last received value for the 'read_write_two_integers' property.
        The 'read_write_two_integers' property contains multiple values, so we operate on the full
        `ReadWriteTwoIntegersProperty` structure.

        This calls back into the application code to get the current value of the property.

        """
        return self._property_read_write_two_integers.get_value()

    @read_write_two_integers.setter
    def read_write_two_integers(self, value: ReadWriteTwoIntegersProperty):
        """This property sets (publishes) a new value structure for the 'read_write_two_integers' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, ReadWriteTwoIntegersProperty):
            raise ValueError(f"The value must be ReadWriteTwoIntegersProperty.")

            value_updated = False
            with self._property_read_write_two_integers.mutex:
                if value != self._property_read_write_two_integers.get_value():
                    value_updated = True
                    self._property_read_write_two_integers.set_value(value)
                    self._property_read_write_two_integers.version += 1
                    state_msg = MessageCreator.property_state_message(
                        "testable/{}/property/readWriteTwoIntegers/value".format(self._instance_id), self._property_read_write_two_integers.get_value(), self._property_read_write_two_integers.version
                    )
                    self._conn.publish(state_msg)

    def set_read_write_two_integers(self, first: int, second: Optional[int]):
        """This method sets (publishes) a new value for the 'read_write_two_integers' property."""
        if not isinstance(first, int):
            raise ValueError(f"The 'first' value must be int.")
        if not isinstance(second, int) and second is not None:
            raise ValueError(f"The 'second' value must be Optional[int].")

        obj = ReadWriteTwoIntegersProperty(
            first=first,
            second=second,
        )

        # Use the property.setter to do that actual work.
        self.read_write_two_integers = obj

    def on_read_write_two_integers_updated(self, handler: Callable[[int, Optional[int]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_integers' property update is received."""

        def wrapper(value: ReadWriteTwoIntegersProperty):
            handler(
                value.first,
                value.second,
            )

        self._property_read_write_two_integers.callbacks.append(wrapper)

    @property
    def read_only_string(self) -> Optional[str]:
        """This property returns the last received (str) value for the 'read_only_string' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_only_string.get_value()

    @read_only_string.setter
    def read_only_string(self, value: str):
        """This property sets (publishes) a new str value for the 'read_only_string' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, str):
            raise ValueError(f"The value must be str .")

        value_updated = False
        with self._property_read_only_string.mutex:
            if value != self._property_read_only_string.get_value():
                value_updated = True
                self._property_read_only_string.set_value(value)
                self._property_read_only_string.version += 1
                prop_obj = ReadOnlyStringProperty(value=self._property_read_only_string.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readOnlyString/value".format(self._instance_id), prop_obj, self._property_read_only_string.version)
                self._conn.publish(state_msg)

    def set_read_only_string(self, value: str):
        """This method sets (publishes) a new value for the 'read_only_string' property."""
        if not isinstance(value, str):
            raise ValueError(f"The 'value' value must be str.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_only_string = obj

    def on_read_only_string_updated(self, handler: Callable[[str], None]):
        """This method registers a callback to be called whenever a new 'read_only_string' property update is received."""
        self._property_read_only_string.callbacks.append(handler)

    @property
    def read_write_string(self) -> Optional[str]:
        """This property returns the last received (str) value for the 'read_write_string' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_string.get_value()

    @read_write_string.setter
    def read_write_string(self, value: str):
        """This property sets (publishes) a new str value for the 'read_write_string' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, str):
            raise ValueError(f"The value must be str .")

        value_updated = False
        with self._property_read_write_string.mutex:
            if value != self._property_read_write_string.get_value():
                value_updated = True
                self._property_read_write_string.set_value(value)
                self._property_read_write_string.version += 1
                prop_obj = ReadWriteStringProperty(value=self._property_read_write_string.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteString/value".format(self._instance_id), prop_obj, self._property_read_write_string.version)
                self._conn.publish(state_msg)

    def set_read_write_string(self, value: str):
        """This method sets (publishes) a new value for the 'read_write_string' property."""
        if not isinstance(value, str):
            raise ValueError(f"The 'value' value must be str.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_string = obj

    def on_read_write_string_updated(self, handler: Callable[[str], None]):
        """This method registers a callback to be called whenever a new 'read_write_string' property update is received."""
        self._property_read_write_string.callbacks.append(handler)

    @property
    def read_write_optional_string(self) -> Optional[str]:
        """This property returns the last received (Optional[str]) value for the 'read_write_optional_string' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_optional_string.get_value()

    @read_write_optional_string.setter
    def read_write_optional_string(self, value: Optional[str]):
        """This property sets (publishes) a new Optional[str] value for the 'read_write_optional_string' property.

        This call the setter callback into the application code to set the property value.
        """
        if (value is not None) and (not isinstance(value, str)):
            raise ValueError(f"The value must be str or None.")

        value_updated = False
        with self._property_read_write_optional_string.mutex:
            if value != self._property_read_write_optional_string.get_value():
                value_updated = True
                self._property_read_write_optional_string.set_value(value)
                self._property_read_write_optional_string.version += 1
                prop_obj = ReadWriteOptionalStringProperty(value=self._property_read_write_optional_string.get_value())
                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalString/value".format(self._instance_id), prop_obj, self._property_read_write_optional_string.version
                )
                self._conn.publish(state_msg)

    def set_read_write_optional_string(self, value: Optional[str]):
        """This method sets (publishes) a new value for the 'read_write_optional_string' property."""
        if not isinstance(value, str) and value is not None:
            raise ValueError(f"The 'value' value must be Optional[str].")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_optional_string = obj

    def on_read_write_optional_string_updated(self, handler: Callable[[Optional[str]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_string' property update is received."""
        self._property_read_write_optional_string.callbacks.append(handler)

    @property
    def read_write_two_strings(self) -> ReadWriteTwoStringsProperty:
        """This property returns the last received value for the 'read_write_two_strings' property.
        The 'read_write_two_strings' property contains multiple values, so we operate on the full
        `ReadWriteTwoStringsProperty` structure.

        This calls back into the application code to get the current value of the property.

        """
        return self._property_read_write_two_strings.get_value()

    @read_write_two_strings.setter
    def read_write_two_strings(self, value: ReadWriteTwoStringsProperty):
        """This property sets (publishes) a new value structure for the 'read_write_two_strings' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, ReadWriteTwoStringsProperty):
            raise ValueError(f"The value must be ReadWriteTwoStringsProperty.")

            value_updated = False
            with self._property_read_write_two_strings.mutex:
                if value != self._property_read_write_two_strings.get_value():
                    value_updated = True
                    self._property_read_write_two_strings.set_value(value)
                    self._property_read_write_two_strings.version += 1
                    state_msg = MessageCreator.property_state_message(
                        "testable/{}/property/readWriteTwoStrings/value".format(self._instance_id), self._property_read_write_two_strings.get_value(), self._property_read_write_two_strings.version
                    )
                    self._conn.publish(state_msg)

    def set_read_write_two_strings(self, first: str, second: Optional[str]):
        """This method sets (publishes) a new value for the 'read_write_two_strings' property."""
        if not isinstance(first, str):
            raise ValueError(f"The 'first' value must be str.")
        if not isinstance(second, str) and second is not None:
            raise ValueError(f"The 'second' value must be Optional[str].")

        obj = ReadWriteTwoStringsProperty(
            first=first,
            second=second,
        )

        # Use the property.setter to do that actual work.
        self.read_write_two_strings = obj

    def on_read_write_two_strings_updated(self, handler: Callable[[str, Optional[str]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_strings' property update is received."""

        def wrapper(value: ReadWriteTwoStringsProperty):
            handler(
                value.first,
                value.second,
            )

        self._property_read_write_two_strings.callbacks.append(wrapper)

    @property
    def read_write_struct(self) -> Optional[AllTypes]:
        """This property returns the last received (AllTypes) value for the 'read_write_struct' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_struct.get_value()

    @read_write_struct.setter
    def read_write_struct(self, value: AllTypes):
        """This property sets (publishes) a new AllTypes value for the 'read_write_struct' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, AllTypes):
            raise ValueError(f"The value must be AllTypes .")

        value_updated = False
        with self._property_read_write_struct.mutex:
            if value != self._property_read_write_struct.get_value():
                value_updated = True
                self._property_read_write_struct.set_value(value)
                self._property_read_write_struct.version += 1
                prop_obj = ReadWriteStructProperty(value=self._property_read_write_struct.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteStruct/value".format(self._instance_id), prop_obj, self._property_read_write_struct.version)
                self._conn.publish(state_msg)

    def set_read_write_struct(self, value: AllTypes):
        """This method sets (publishes) a new value for the 'read_write_struct' property."""
        if not isinstance(value, AllTypes):
            raise ValueError(f"The 'value' value must be AllTypes.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_struct = obj

    def on_read_write_struct_updated(self, handler: Callable[[AllTypes], None]):
        """This method registers a callback to be called whenever a new 'read_write_struct' property update is received."""
        self._property_read_write_struct.callbacks.append(handler)

    @property
    def read_write_optional_struct(self) -> AllTypes:
        """This property returns the last received (AllTypes) value for the 'read_write_optional_struct' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_optional_struct.get_value()

    @read_write_optional_struct.setter
    def read_write_optional_struct(self, value: AllTypes):
        """This property sets (publishes) a new AllTypes value for the 'read_write_optional_struct' property.

        This call the setter callback into the application code to set the property value.
        """
        if (value is not None) and (not isinstance(value, AllTypes)):
            raise ValueError(f"The value must be AllTypes or None.")

        value_updated = False
        with self._property_read_write_optional_struct.mutex:
            if value != self._property_read_write_optional_struct.get_value():
                value_updated = True
                self._property_read_write_optional_struct.set_value(value)
                self._property_read_write_optional_struct.version += 1
                prop_obj = ReadWriteOptionalStructProperty(value=self._property_read_write_optional_struct.get_value())
                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalStruct/value".format(self._instance_id), prop_obj, self._property_read_write_optional_struct.version
                )
                self._conn.publish(state_msg)

    def set_read_write_optional_struct(self, value: AllTypes):
        """This method sets (publishes) a new value for the 'read_write_optional_struct' property."""
        if not isinstance(value, AllTypes) and value is not None:
            raise ValueError(f"The 'value' value must be AllTypes.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_optional_struct = obj

    def on_read_write_optional_struct_updated(self, handler: Callable[[AllTypes], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_struct' property update is received."""
        self._property_read_write_optional_struct.callbacks.append(handler)

    @property
    def read_write_two_structs(self) -> ReadWriteTwoStructsProperty:
        """This property returns the last received value for the 'read_write_two_structs' property.
        The 'read_write_two_structs' property contains multiple values, so we operate on the full
        `ReadWriteTwoStructsProperty` structure.

        This calls back into the application code to get the current value of the property.

        """
        return self._property_read_write_two_structs.get_value()

    @read_write_two_structs.setter
    def read_write_two_structs(self, value: ReadWriteTwoStructsProperty):
        """This property sets (publishes) a new value structure for the 'read_write_two_structs' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, ReadWriteTwoStructsProperty):
            raise ValueError(f"The value must be ReadWriteTwoStructsProperty.")

            value_updated = False
            with self._property_read_write_two_structs.mutex:
                if value != self._property_read_write_two_structs.get_value():
                    value_updated = True
                    self._property_read_write_two_structs.set_value(value)
                    self._property_read_write_two_structs.version += 1
                    state_msg = MessageCreator.property_state_message(
                        "testable/{}/property/readWriteTwoStructs/value".format(self._instance_id), self._property_read_write_two_structs.get_value(), self._property_read_write_two_structs.version
                    )
                    self._conn.publish(state_msg)

    def set_read_write_two_structs(self, first: AllTypes, second: AllTypes):
        """This method sets (publishes) a new value for the 'read_write_two_structs' property."""
        if not isinstance(first, AllTypes):
            raise ValueError(f"The 'first' value must be AllTypes.")
        if not isinstance(second, AllTypes) and second is not None:
            raise ValueError(f"The 'second' value must be AllTypes.")

        obj = ReadWriteTwoStructsProperty(
            first=first,
            second=second,
        )

        # Use the property.setter to do that actual work.
        self.read_write_two_structs = obj

    def on_read_write_two_structs_updated(self, handler: Callable[[AllTypes, AllTypes], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_structs' property update is received."""

        def wrapper(value: ReadWriteTwoStructsProperty):
            handler(
                value.first,
                value.second,
            )

        self._property_read_write_two_structs.callbacks.append(wrapper)

    @property
    def read_only_enum(self) -> Optional[Numbers]:
        """This property returns the last received (Numbers) value for the 'read_only_enum' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_only_enum.get_value()

    @read_only_enum.setter
    def read_only_enum(self, value: Numbers):
        """This property sets (publishes) a new Numbers value for the 'read_only_enum' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, Numbers):
            raise ValueError(f"The value must be Numbers .")

        value_updated = False
        with self._property_read_only_enum.mutex:
            if value != self._property_read_only_enum.get_value():
                value_updated = True
                self._property_read_only_enum.set_value(value)
                self._property_read_only_enum.version += 1
                prop_obj = ReadOnlyEnumProperty(value=self._property_read_only_enum.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readOnlyEnum/value".format(self._instance_id), prop_obj, self._property_read_only_enum.version)
                self._conn.publish(state_msg)

    def set_read_only_enum(self, value: Numbers):
        """This method sets (publishes) a new value for the 'read_only_enum' property."""
        if not isinstance(value, Numbers):
            raise ValueError(f"The 'value' value must be Numbers.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_only_enum = obj

    def on_read_only_enum_updated(self, handler: Callable[[Numbers], None]):
        """This method registers a callback to be called whenever a new 'read_only_enum' property update is received."""
        self._property_read_only_enum.callbacks.append(handler)

    @property
    def read_write_enum(self) -> Optional[Numbers]:
        """This property returns the last received (Numbers) value for the 'read_write_enum' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_enum.get_value()

    @read_write_enum.setter
    def read_write_enum(self, value: Numbers):
        """This property sets (publishes) a new Numbers value for the 'read_write_enum' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, Numbers):
            raise ValueError(f"The value must be Numbers .")

        value_updated = False
        with self._property_read_write_enum.mutex:
            if value != self._property_read_write_enum.get_value():
                value_updated = True
                self._property_read_write_enum.set_value(value)
                self._property_read_write_enum.version += 1
                prop_obj = ReadWriteEnumProperty(value=self._property_read_write_enum.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteEnum/value".format(self._instance_id), prop_obj, self._property_read_write_enum.version)
                self._conn.publish(state_msg)

    def set_read_write_enum(self, value: Numbers):
        """This method sets (publishes) a new value for the 'read_write_enum' property."""
        if not isinstance(value, Numbers):
            raise ValueError(f"The 'value' value must be Numbers.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_enum = obj

    def on_read_write_enum_updated(self, handler: Callable[[Numbers], None]):
        """This method registers a callback to be called whenever a new 'read_write_enum' property update is received."""
        self._property_read_write_enum.callbacks.append(handler)

    @property
    def read_write_optional_enum(self) -> Optional[Numbers]:
        """This property returns the last received (Optional[Numbers]) value for the 'read_write_optional_enum' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_optional_enum.get_value()

    @read_write_optional_enum.setter
    def read_write_optional_enum(self, value: Optional[Numbers]):
        """This property sets (publishes) a new Optional[Numbers] value for the 'read_write_optional_enum' property.

        This call the setter callback into the application code to set the property value.
        """
        if (value is not None) and (not isinstance(value, Numbers)):
            raise ValueError(f"The value must be Numbers or None.")

        value_updated = False
        with self._property_read_write_optional_enum.mutex:
            if value != self._property_read_write_optional_enum.get_value():
                value_updated = True
                self._property_read_write_optional_enum.set_value(value)
                self._property_read_write_optional_enum.version += 1
                prop_obj = ReadWriteOptionalEnumProperty(value=self._property_read_write_optional_enum.get_value())
                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalEnum/value".format(self._instance_id), prop_obj, self._property_read_write_optional_enum.version
                )
                self._conn.publish(state_msg)

    def set_read_write_optional_enum(self, value: Optional[Numbers]):
        """This method sets (publishes) a new value for the 'read_write_optional_enum' property."""
        if not isinstance(value, Numbers) and value is not None:
            raise ValueError(f"The 'value' value must be Optional[Numbers].")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_optional_enum = obj

    def on_read_write_optional_enum_updated(self, handler: Callable[[Optional[Numbers]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_enum' property update is received."""
        self._property_read_write_optional_enum.callbacks.append(handler)

    @property
    def read_write_two_enums(self) -> ReadWriteTwoEnumsProperty:
        """This property returns the last received value for the 'read_write_two_enums' property.
        The 'read_write_two_enums' property contains multiple values, so we operate on the full
        `ReadWriteTwoEnumsProperty` structure.

        This calls back into the application code to get the current value of the property.

        """
        return self._property_read_write_two_enums.get_value()

    @read_write_two_enums.setter
    def read_write_two_enums(self, value: ReadWriteTwoEnumsProperty):
        """This property sets (publishes) a new value structure for the 'read_write_two_enums' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, ReadWriteTwoEnumsProperty):
            raise ValueError(f"The value must be ReadWriteTwoEnumsProperty.")

            value_updated = False
            with self._property_read_write_two_enums.mutex:
                if value != self._property_read_write_two_enums.get_value():
                    value_updated = True
                    self._property_read_write_two_enums.set_value(value)
                    self._property_read_write_two_enums.version += 1
                    state_msg = MessageCreator.property_state_message(
                        "testable/{}/property/readWriteTwoEnums/value".format(self._instance_id), self._property_read_write_two_enums.get_value(), self._property_read_write_two_enums.version
                    )
                    self._conn.publish(state_msg)

    def set_read_write_two_enums(self, first: Numbers, second: Optional[Numbers]):
        """This method sets (publishes) a new value for the 'read_write_two_enums' property."""
        if not isinstance(first, Numbers):
            raise ValueError(f"The 'first' value must be Numbers.")
        if not isinstance(second, Numbers) and second is not None:
            raise ValueError(f"The 'second' value must be Optional[Numbers].")

        obj = ReadWriteTwoEnumsProperty(
            first=first,
            second=second,
        )

        # Use the property.setter to do that actual work.
        self.read_write_two_enums = obj

    def on_read_write_two_enums_updated(self, handler: Callable[[Numbers, Optional[Numbers]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_enums' property update is received."""

        def wrapper(value: ReadWriteTwoEnumsProperty):
            handler(
                value.first,
                value.second,
            )

        self._property_read_write_two_enums.callbacks.append(wrapper)

    @property
    def read_write_datetime(self) -> Optional[datetime]:
        """This property returns the last received (datetime) value for the 'read_write_datetime' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_datetime.get_value()

    @read_write_datetime.setter
    def read_write_datetime(self, value: datetime):
        """This property sets (publishes) a new datetime value for the 'read_write_datetime' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, datetime):
            raise ValueError(f"The value must be datetime .")

        value_updated = False
        with self._property_read_write_datetime.mutex:
            if value != self._property_read_write_datetime.get_value():
                value_updated = True
                self._property_read_write_datetime.set_value(value)
                self._property_read_write_datetime.version += 1
                prop_obj = ReadWriteDatetimeProperty(value=self._property_read_write_datetime.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteDatetime/value".format(self._instance_id), prop_obj, self._property_read_write_datetime.version)
                self._conn.publish(state_msg)

    def set_read_write_datetime(self, value: datetime):
        """This method sets (publishes) a new value for the 'read_write_datetime' property."""
        if not isinstance(value, datetime):
            raise ValueError(f"The 'value' value must be datetime.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_datetime = obj

    def on_read_write_datetime_updated(self, handler: Callable[[datetime], None]):
        """This method registers a callback to be called whenever a new 'read_write_datetime' property update is received."""
        self._property_read_write_datetime.callbacks.append(handler)

    @property
    def read_write_optional_datetime(self) -> Optional[datetime]:
        """This property returns the last received (Optional[datetime]) value for the 'read_write_optional_datetime' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_optional_datetime.get_value()

    @read_write_optional_datetime.setter
    def read_write_optional_datetime(self, value: Optional[datetime]):
        """This property sets (publishes) a new Optional[datetime] value for the 'read_write_optional_datetime' property.

        This call the setter callback into the application code to set the property value.
        """
        if (value is not None) and (not isinstance(value, datetime)):
            raise ValueError(f"The value must be datetime or None.")

        value_updated = False
        with self._property_read_write_optional_datetime.mutex:
            if value != self._property_read_write_optional_datetime.get_value():
                value_updated = True
                self._property_read_write_optional_datetime.set_value(value)
                self._property_read_write_optional_datetime.version += 1
                prop_obj = ReadWriteOptionalDatetimeProperty(value=self._property_read_write_optional_datetime.get_value())
                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalDatetime/value".format(self._instance_id), prop_obj, self._property_read_write_optional_datetime.version
                )
                self._conn.publish(state_msg)

    def set_read_write_optional_datetime(self, value: Optional[datetime]):
        """This method sets (publishes) a new value for the 'read_write_optional_datetime' property."""
        if not isinstance(value, datetime) and value is not None:
            raise ValueError(f"The 'value' value must be Optional[datetime].")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_optional_datetime = obj

    def on_read_write_optional_datetime_updated(self, handler: Callable[[Optional[datetime]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_datetime' property update is received."""
        self._property_read_write_optional_datetime.callbacks.append(handler)

    @property
    def read_write_two_datetimes(self) -> ReadWriteTwoDatetimesProperty:
        """This property returns the last received value for the 'read_write_two_datetimes' property.
        The 'read_write_two_datetimes' property contains multiple values, so we operate on the full
        `ReadWriteTwoDatetimesProperty` structure.

        This calls back into the application code to get the current value of the property.

        """
        return self._property_read_write_two_datetimes.get_value()

    @read_write_two_datetimes.setter
    def read_write_two_datetimes(self, value: ReadWriteTwoDatetimesProperty):
        """This property sets (publishes) a new value structure for the 'read_write_two_datetimes' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, ReadWriteTwoDatetimesProperty):
            raise ValueError(f"The value must be ReadWriteTwoDatetimesProperty.")

            value_updated = False
            with self._property_read_write_two_datetimes.mutex:
                if value != self._property_read_write_two_datetimes.get_value():
                    value_updated = True
                    self._property_read_write_two_datetimes.set_value(value)
                    self._property_read_write_two_datetimes.version += 1
                    state_msg = MessageCreator.property_state_message(
                        "testable/{}/property/readWriteTwoDatetimes/value".format(self._instance_id),
                        self._property_read_write_two_datetimes.get_value(),
                        self._property_read_write_two_datetimes.version,
                    )
                    self._conn.publish(state_msg)

    def set_read_write_two_datetimes(self, first: datetime, second: Optional[datetime]):
        """This method sets (publishes) a new value for the 'read_write_two_datetimes' property."""
        if not isinstance(first, datetime):
            raise ValueError(f"The 'first' value must be datetime.")
        if not isinstance(second, datetime) and second is not None:
            raise ValueError(f"The 'second' value must be Optional[datetime].")

        obj = ReadWriteTwoDatetimesProperty(
            first=first,
            second=second,
        )

        # Use the property.setter to do that actual work.
        self.read_write_two_datetimes = obj

    def on_read_write_two_datetimes_updated(self, handler: Callable[[datetime, Optional[datetime]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_datetimes' property update is received."""

        def wrapper(value: ReadWriteTwoDatetimesProperty):
            handler(
                value.first,
                value.second,
            )

        self._property_read_write_two_datetimes.callbacks.append(wrapper)

    @property
    def read_write_duration(self) -> Optional[timedelta]:
        """This property returns the last received (timedelta) value for the 'read_write_duration' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_duration.get_value()

    @read_write_duration.setter
    def read_write_duration(self, value: timedelta):
        """This property sets (publishes) a new timedelta value for the 'read_write_duration' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, timedelta):
            raise ValueError(f"The value must be timedelta .")

        value_updated = False
        with self._property_read_write_duration.mutex:
            if value != self._property_read_write_duration.get_value():
                value_updated = True
                self._property_read_write_duration.set_value(value)
                self._property_read_write_duration.version += 1
                prop_obj = ReadWriteDurationProperty(value=self._property_read_write_duration.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteDuration/value".format(self._instance_id), prop_obj, self._property_read_write_duration.version)
                self._conn.publish(state_msg)

    def set_read_write_duration(self, value: timedelta):
        """This method sets (publishes) a new value for the 'read_write_duration' property."""
        if not isinstance(value, timedelta):
            raise ValueError(f"The 'value' value must be timedelta.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_duration = obj

    def on_read_write_duration_updated(self, handler: Callable[[timedelta], None]):
        """This method registers a callback to be called whenever a new 'read_write_duration' property update is received."""
        self._property_read_write_duration.callbacks.append(handler)

    @property
    def read_write_optional_duration(self) -> Optional[timedelta]:
        """This property returns the last received (Optional[timedelta]) value for the 'read_write_optional_duration' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_optional_duration.get_value()

    @read_write_optional_duration.setter
    def read_write_optional_duration(self, value: Optional[timedelta]):
        """This property sets (publishes) a new Optional[timedelta] value for the 'read_write_optional_duration' property.

        This call the setter callback into the application code to set the property value.
        """
        if (value is not None) and (not isinstance(value, timedelta)):
            raise ValueError(f"The value must be timedelta or None.")

        value_updated = False
        with self._property_read_write_optional_duration.mutex:
            if value != self._property_read_write_optional_duration.get_value():
                value_updated = True
                self._property_read_write_optional_duration.set_value(value)
                self._property_read_write_optional_duration.version += 1
                prop_obj = ReadWriteOptionalDurationProperty(value=self._property_read_write_optional_duration.get_value())
                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalDuration/value".format(self._instance_id), prop_obj, self._property_read_write_optional_duration.version
                )
                self._conn.publish(state_msg)

    def set_read_write_optional_duration(self, value: Optional[timedelta]):
        """This method sets (publishes) a new value for the 'read_write_optional_duration' property."""
        if not isinstance(value, timedelta) and value is not None:
            raise ValueError(f"The 'value' value must be Optional[timedelta].")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_optional_duration = obj

    def on_read_write_optional_duration_updated(self, handler: Callable[[Optional[timedelta]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_duration' property update is received."""
        self._property_read_write_optional_duration.callbacks.append(handler)

    @property
    def read_write_two_durations(self) -> ReadWriteTwoDurationsProperty:
        """This property returns the last received value for the 'read_write_two_durations' property.
        The 'read_write_two_durations' property contains multiple values, so we operate on the full
        `ReadWriteTwoDurationsProperty` structure.

        This calls back into the application code to get the current value of the property.

        """
        return self._property_read_write_two_durations.get_value()

    @read_write_two_durations.setter
    def read_write_two_durations(self, value: ReadWriteTwoDurationsProperty):
        """This property sets (publishes) a new value structure for the 'read_write_two_durations' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, ReadWriteTwoDurationsProperty):
            raise ValueError(f"The value must be ReadWriteTwoDurationsProperty.")

            value_updated = False
            with self._property_read_write_two_durations.mutex:
                if value != self._property_read_write_two_durations.get_value():
                    value_updated = True
                    self._property_read_write_two_durations.set_value(value)
                    self._property_read_write_two_durations.version += 1
                    state_msg = MessageCreator.property_state_message(
                        "testable/{}/property/readWriteTwoDurations/value".format(self._instance_id),
                        self._property_read_write_two_durations.get_value(),
                        self._property_read_write_two_durations.version,
                    )
                    self._conn.publish(state_msg)

    def set_read_write_two_durations(self, first: timedelta, second: Optional[timedelta]):
        """This method sets (publishes) a new value for the 'read_write_two_durations' property."""
        if not isinstance(first, timedelta):
            raise ValueError(f"The 'first' value must be timedelta.")
        if not isinstance(second, timedelta) and second is not None:
            raise ValueError(f"The 'second' value must be Optional[timedelta].")

        obj = ReadWriteTwoDurationsProperty(
            first=first,
            second=second,
        )

        # Use the property.setter to do that actual work.
        self.read_write_two_durations = obj

    def on_read_write_two_durations_updated(self, handler: Callable[[timedelta, Optional[timedelta]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_durations' property update is received."""

        def wrapper(value: ReadWriteTwoDurationsProperty):
            handler(
                value.first,
                value.second,
            )

        self._property_read_write_two_durations.callbacks.append(wrapper)

    @property
    def read_write_binary(self) -> Optional[bytes]:
        """This property returns the last received (bytes) value for the 'read_write_binary' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_binary.get_value()

    @read_write_binary.setter
    def read_write_binary(self, value: bytes):
        """This property sets (publishes) a new bytes value for the 'read_write_binary' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, bytes):
            raise ValueError(f"The value must be bytes .")

        value_updated = False
        with self._property_read_write_binary.mutex:
            if value != self._property_read_write_binary.get_value():
                value_updated = True
                self._property_read_write_binary.set_value(value)
                self._property_read_write_binary.version += 1
                prop_obj = ReadWriteBinaryProperty(value=self._property_read_write_binary.get_value())
                state_msg = MessageCreator.property_state_message("testable/{}/property/readWriteBinary/value".format(self._instance_id), prop_obj, self._property_read_write_binary.version)
                self._conn.publish(state_msg)

    def set_read_write_binary(self, value: bytes):
        """This method sets (publishes) a new value for the 'read_write_binary' property."""
        if not isinstance(value, bytes):
            raise ValueError(f"The 'value' value must be bytes.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_binary = obj

    def on_read_write_binary_updated(self, handler: Callable[[bytes], None]):
        """This method registers a callback to be called whenever a new 'read_write_binary' property update is received."""
        self._property_read_write_binary.callbacks.append(handler)

    @property
    def read_write_optional_binary(self) -> bytes:
        """This property returns the last received (bytes) value for the 'read_write_optional_binary' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_optional_binary.get_value()

    @read_write_optional_binary.setter
    def read_write_optional_binary(self, value: bytes):
        """This property sets (publishes) a new bytes value for the 'read_write_optional_binary' property.

        This call the setter callback into the application code to set the property value.
        """
        if (value is not None) and (not isinstance(value, bytes)):
            raise ValueError(f"The value must be bytes or None.")

        value_updated = False
        with self._property_read_write_optional_binary.mutex:
            if value != self._property_read_write_optional_binary.get_value():
                value_updated = True
                self._property_read_write_optional_binary.set_value(value)
                self._property_read_write_optional_binary.version += 1
                prop_obj = ReadWriteOptionalBinaryProperty(value=self._property_read_write_optional_binary.get_value())
                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteOptionalBinary/value".format(self._instance_id), prop_obj, self._property_read_write_optional_binary.version
                )
                self._conn.publish(state_msg)

    def set_read_write_optional_binary(self, value: bytes):
        """This method sets (publishes) a new value for the 'read_write_optional_binary' property."""
        if not isinstance(value, bytes) and value is not None:
            raise ValueError(f"The 'value' value must be bytes.")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_optional_binary = obj

    def on_read_write_optional_binary_updated(self, handler: Callable[[bytes], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_binary' property update is received."""
        self._property_read_write_optional_binary.callbacks.append(handler)

    @property
    def read_write_two_binaries(self) -> ReadWriteTwoBinariesProperty:
        """This property returns the last received value for the 'read_write_two_binaries' property.
        The 'read_write_two_binaries' property contains multiple values, so we operate on the full
        `ReadWriteTwoBinariesProperty` structure.

        This calls back into the application code to get the current value of the property.

        """
        return self._property_read_write_two_binaries.get_value()

    @read_write_two_binaries.setter
    def read_write_two_binaries(self, value: ReadWriteTwoBinariesProperty):
        """This property sets (publishes) a new value structure for the 'read_write_two_binaries' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, ReadWriteTwoBinariesProperty):
            raise ValueError(f"The value must be ReadWriteTwoBinariesProperty.")

            value_updated = False
            with self._property_read_write_two_binaries.mutex:
                if value != self._property_read_write_two_binaries.get_value():
                    value_updated = True
                    self._property_read_write_two_binaries.set_value(value)
                    self._property_read_write_two_binaries.version += 1
                    state_msg = MessageCreator.property_state_message(
                        "testable/{}/property/readWriteTwoBinaries/value".format(self._instance_id), self._property_read_write_two_binaries.get_value(), self._property_read_write_two_binaries.version
                    )
                    self._conn.publish(state_msg)

    def set_read_write_two_binaries(self, first: bytes, second: bytes):
        """This method sets (publishes) a new value for the 'read_write_two_binaries' property."""
        if not isinstance(first, bytes):
            raise ValueError(f"The 'first' value must be bytes.")
        if not isinstance(second, bytes) and second is not None:
            raise ValueError(f"The 'second' value must be bytes.")

        obj = ReadWriteTwoBinariesProperty(
            first=first,
            second=second,
        )

        # Use the property.setter to do that actual work.
        self.read_write_two_binaries = obj

    def on_read_write_two_binaries_updated(self, handler: Callable[[bytes, bytes], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_binaries' property update is received."""

        def wrapper(value: ReadWriteTwoBinariesProperty):
            handler(
                value.first,
                value.second,
            )

        self._property_read_write_two_binaries.callbacks.append(wrapper)

    @property
    def read_write_list_of_strings(self) -> Optional[List[str]]:
        """This property returns the last received (List[str]) value for the 'read_write_list_of_strings' property.

        This calls back into the application code to get the current value of the property.
        """
        return self._property_read_write_list_of_strings.get_value()

    @read_write_list_of_strings.setter
    def read_write_list_of_strings(self, value: List[str]):
        """This property sets (publishes) a new List[str] value for the 'read_write_list_of_strings' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, list):
            raise ValueError(f"The value must be list .")

        value_updated = False
        with self._property_read_write_list_of_strings.mutex:
            if value != self._property_read_write_list_of_strings.get_value():
                value_updated = True
                self._property_read_write_list_of_strings.set_value(value)
                self._property_read_write_list_of_strings.version += 1
                prop_obj = ReadWriteListOfStringsProperty(value=self._property_read_write_list_of_strings.get_value())
                state_msg = MessageCreator.property_state_message(
                    "testable/{}/property/readWriteListOfStrings/value".format(self._instance_id), prop_obj, self._property_read_write_list_of_strings.version
                )
                self._conn.publish(state_msg)

    def set_read_write_list_of_strings(self, value: List[str]):
        """This method sets (publishes) a new value for the 'read_write_list_of_strings' property."""
        if not isinstance(value, list):
            raise ValueError(f"The 'value' value must be List[str].")

        obj = value

        # Use the property.setter to do that actual work.
        self.read_write_list_of_strings = obj

    def on_read_write_list_of_strings_updated(self, handler: Callable[[List[str]], None]):
        """This method registers a callback to be called whenever a new 'read_write_list_of_strings' property update is received."""
        self._property_read_write_list_of_strings.callbacks.append(handler)

    @property
    def read_write_lists(self) -> ReadWriteListsProperty:
        """This property returns the last received value for the 'read_write_lists' property.
        The 'read_write_lists' property contains multiple values, so we operate on the full
        `ReadWriteListsProperty` structure.

        This calls back into the application code to get the current value of the property.

        """
        return self._property_read_write_lists.get_value()

    @read_write_lists.setter
    def read_write_lists(self, value: ReadWriteListsProperty):
        """This property sets (publishes) a new value structure for the 'read_write_lists' property.

        This call the setter callback into the application code to set the property value.
        """
        if not isinstance(value, ReadWriteListsProperty):
            raise ValueError(f"The value must be ReadWriteListsProperty.")

            value_updated = False
            with self._property_read_write_lists.mutex:
                if value != self._property_read_write_lists.get_value():
                    value_updated = True
                    self._property_read_write_lists.set_value(value)
                    self._property_read_write_lists.version += 1
                    state_msg = MessageCreator.property_state_message(
                        "testable/{}/property/readWriteLists/value".format(self._instance_id), self._property_read_write_lists.get_value(), self._property_read_write_lists.version
                    )
                    self._conn.publish(state_msg)

    def set_read_write_lists(self, the_list: List[Numbers], optional_list: List[datetime]):
        """This method sets (publishes) a new value for the 'read_write_lists' property."""
        if not isinstance(the_list, list):
            raise ValueError(f"The 'the_list' value must be List[Numbers].")
        if not isinstance(optional_list, list) and optional_list is not None:
            raise ValueError(f"The 'optional_list' value must be List[datetime].")

        obj = ReadWriteListsProperty(
            the_list=the_list,
            optionalList=optional_list,
        )

        # Use the property.setter to do that actual work.
        self.read_write_lists = obj

    def on_read_write_lists_updated(self, handler: Callable[[List[Numbers], List[datetime]], None]):
        """This method registers a callback to be called whenever a new 'read_write_lists' property update is received."""

        def wrapper(value: ReadWriteListsProperty):
            handler(
                value.the_list,
                value.optional_list,
            )

        self._property_read_write_lists.callbacks.append(wrapper)


class TestableServerBuilder:
    """
    This is a builder for the TestableServer.  It is used to create a server with the desired parameters.
    """

    def __init__(self):

        self._call_with_nothing_method_handler: Optional[Callable[[], None]] = None
        self._call_one_integer_method_handler: Optional[Callable[[int], int]] = None
        self._call_optional_integer_method_handler: Optional[Callable[[Optional[int]], Optional[int]]] = None
        self._call_three_integers_method_handler: Optional[Callable[[int, int, Optional[int]], CallThreeIntegersMethodResponse]] = None
        self._call_one_string_method_handler: Optional[Callable[[str], str]] = None
        self._call_optional_string_method_handler: Optional[Callable[[Optional[str]], Optional[str]]] = None
        self._call_three_strings_method_handler: Optional[Callable[[str, Optional[str], str], CallThreeStringsMethodResponse]] = None
        self._call_one_enum_method_handler: Optional[Callable[[Numbers], Numbers]] = None
        self._call_optional_enum_method_handler: Optional[Callable[[Optional[Numbers]], Optional[Numbers]]] = None
        self._call_three_enums_method_handler: Optional[Callable[[Numbers, Numbers, Optional[Numbers]], CallThreeEnumsMethodResponse]] = None
        self._call_one_struct_method_handler: Optional[Callable[[AllTypes], AllTypes]] = None
        self._call_optional_struct_method_handler: Optional[Callable[[AllTypes], AllTypes]] = None
        self._call_three_structs_method_handler: Optional[Callable[[AllTypes, AllTypes, AllTypes], CallThreeStructsMethodResponse]] = None
        self._call_one_date_time_method_handler: Optional[Callable[[datetime], datetime]] = None
        self._call_optional_date_time_method_handler: Optional[Callable[[Optional[datetime]], Optional[datetime]]] = None
        self._call_three_date_times_method_handler: Optional[Callable[[datetime, datetime, Optional[datetime]], CallThreeDateTimesMethodResponse]] = None
        self._call_one_duration_method_handler: Optional[Callable[[timedelta], timedelta]] = None
        self._call_optional_duration_method_handler: Optional[Callable[[Optional[timedelta]], Optional[timedelta]]] = None
        self._call_three_durations_method_handler: Optional[Callable[[timedelta, timedelta, Optional[timedelta]], CallThreeDurationsMethodResponse]] = None
        self._call_one_binary_method_handler: Optional[Callable[[bytes], bytes]] = None
        self._call_optional_binary_method_handler: Optional[Callable[[bytes], bytes]] = None
        self._call_three_binaries_method_handler: Optional[Callable[[bytes, bytes, bytes], CallThreeBinariesMethodResponse]] = None
        self._call_one_list_of_integers_method_handler: Optional[Callable[[List[int]], List[int]]] = None
        self._call_optional_list_of_floats_method_handler: Optional[Callable[[List[float]], List[float]]] = None
        self._call_two_lists_method_handler: Optional[Callable[[List[Numbers], List[str]], CallTwoListsMethodResponse]] = None

        self._read_write_integer_property_callbacks: List[Callable[[int], None]] = []
        self._read_only_integer_property_callbacks: List[Callable[[int], None]] = []
        self._read_write_optional_integer_property_callbacks: List[Callable[[Optional[int]], None]] = []
        self._read_write_two_integers_property_callbacks: List[Callable[[int, Optional[int]], None]] = []
        self._read_only_string_property_callbacks: List[Callable[[str], None]] = []
        self._read_write_string_property_callbacks: List[Callable[[str], None]] = []
        self._read_write_optional_string_property_callbacks: List[Callable[[Optional[str]], None]] = []
        self._read_write_two_strings_property_callbacks: List[Callable[[str, Optional[str]], None]] = []
        self._read_write_struct_property_callbacks: List[Callable[[AllTypes], None]] = []
        self._read_write_optional_struct_property_callbacks: List[Callable[[AllTypes], None]] = []
        self._read_write_two_structs_property_callbacks: List[Callable[[AllTypes, AllTypes], None]] = []
        self._read_only_enum_property_callbacks: List[Callable[[Numbers], None]] = []
        self._read_write_enum_property_callbacks: List[Callable[[Numbers], None]] = []
        self._read_write_optional_enum_property_callbacks: List[Callable[[Optional[Numbers]], None]] = []
        self._read_write_two_enums_property_callbacks: List[Callable[[Numbers, Optional[Numbers]], None]] = []
        self._read_write_datetime_property_callbacks: List[Callable[[datetime], None]] = []
        self._read_write_optional_datetime_property_callbacks: List[Callable[[Optional[datetime]], None]] = []
        self._read_write_two_datetimes_property_callbacks: List[Callable[[datetime, Optional[datetime]], None]] = []
        self._read_write_duration_property_callbacks: List[Callable[[timedelta], None]] = []
        self._read_write_optional_duration_property_callbacks: List[Callable[[Optional[timedelta]], None]] = []
        self._read_write_two_durations_property_callbacks: List[Callable[[timedelta, Optional[timedelta]], None]] = []
        self._read_write_binary_property_callbacks: List[Callable[[bytes], None]] = []
        self._read_write_optional_binary_property_callbacks: List[Callable[[bytes], None]] = []
        self._read_write_two_binaries_property_callbacks: List[Callable[[bytes, bytes], None]] = []
        self._read_write_list_of_strings_property_callbacks: List[Callable[[List[str]], None]] = []
        self._read_write_lists_property_callbacks: List[Callable[[List[Numbers], List[datetime]], None]] = []

    def handle_call_with_nothing(self, handler: Callable[[], None]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_with_nothing_method_handler is None and handler is not None:
            self._call_with_nothing_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_one_integer(self, handler: Callable[[int], int]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_one_integer_method_handler is None and handler is not None:
            self._call_one_integer_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_optional_integer(self, handler: Callable[[Optional[int]], Optional[int]]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_optional_integer_method_handler is None and handler is not None:
            self._call_optional_integer_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_three_integers(self, handler: Callable[[int, int, Optional[int]], CallThreeIntegersMethodResponse]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_three_integers_method_handler is None and handler is not None:
            self._call_three_integers_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_one_string(self, handler: Callable[[str], str]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_one_string_method_handler is None and handler is not None:
            self._call_one_string_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_optional_string(self, handler: Callable[[Optional[str]], Optional[str]]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_optional_string_method_handler is None and handler is not None:
            self._call_optional_string_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_three_strings(self, handler: Callable[[str, Optional[str], str], CallThreeStringsMethodResponse]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_three_strings_method_handler is None and handler is not None:
            self._call_three_strings_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_one_enum(self, handler: Callable[[Numbers], Numbers]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_one_enum_method_handler is None and handler is not None:
            self._call_one_enum_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_optional_enum(self, handler: Callable[[Optional[Numbers]], Optional[Numbers]]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_optional_enum_method_handler is None and handler is not None:
            self._call_optional_enum_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_three_enums(self, handler: Callable[[Numbers, Numbers, Optional[Numbers]], CallThreeEnumsMethodResponse]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_three_enums_method_handler is None and handler is not None:
            self._call_three_enums_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_one_struct(self, handler: Callable[[AllTypes], AllTypes]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_one_struct_method_handler is None and handler is not None:
            self._call_one_struct_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_optional_struct(self, handler: Callable[[AllTypes], AllTypes]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_optional_struct_method_handler is None and handler is not None:
            self._call_optional_struct_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_three_structs(self, handler: Callable[[AllTypes, AllTypes, AllTypes], CallThreeStructsMethodResponse]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_three_structs_method_handler is None and handler is not None:
            self._call_three_structs_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_one_date_time(self, handler: Callable[[datetime], datetime]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_one_date_time_method_handler is None and handler is not None:
            self._call_one_date_time_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_optional_date_time(self, handler: Callable[[Optional[datetime]], Optional[datetime]]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_optional_date_time_method_handler is None and handler is not None:
            self._call_optional_date_time_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_three_date_times(self, handler: Callable[[datetime, datetime, Optional[datetime]], CallThreeDateTimesMethodResponse]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_three_date_times_method_handler is None and handler is not None:
            self._call_three_date_times_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_one_duration(self, handler: Callable[[timedelta], timedelta]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_one_duration_method_handler is None and handler is not None:
            self._call_one_duration_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_optional_duration(self, handler: Callable[[Optional[timedelta]], Optional[timedelta]]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_optional_duration_method_handler is None and handler is not None:
            self._call_optional_duration_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_three_durations(self, handler: Callable[[timedelta, timedelta, Optional[timedelta]], CallThreeDurationsMethodResponse]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_three_durations_method_handler is None and handler is not None:
            self._call_three_durations_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_one_binary(self, handler: Callable[[bytes], bytes]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_one_binary_method_handler is None and handler is not None:
            self._call_one_binary_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_optional_binary(self, handler: Callable[[bytes], bytes]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_optional_binary_method_handler is None and handler is not None:
            self._call_optional_binary_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_three_binaries(self, handler: Callable[[bytes, bytes, bytes], CallThreeBinariesMethodResponse]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_three_binaries_method_handler is None and handler is not None:
            self._call_three_binaries_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_one_list_of_integers(self, handler: Callable[[List[int]], List[int]]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_one_list_of_integers_method_handler is None and handler is not None:
            self._call_one_list_of_integers_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_optional_list_of_floats(self, handler: Callable[[List[float]], List[float]]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_optional_list_of_floats_method_handler is None and handler is not None:
            self._call_optional_list_of_floats_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def handle_call_two_lists(self, handler: Callable[[List[Numbers], List[str]], CallTwoListsMethodResponse]):
        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        if self._call_two_lists_method_handler is None and handler is not None:
            self._call_two_lists_method_handler = wrapper
        else:
            raise Exception("Method handler already set")
        return wrapper

    def on_read_write_integer_updated(self, handler: Callable[[int], None]):
        """This method registers a callback to be called whenever a new 'read_write_integer' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_integer_property_callbacks.append(wrapper)
        return wrapper

    def on_read_only_integer_updated(self, handler: Callable[[int], None]):
        """This method registers a callback to be called whenever a new 'read_only_integer' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_only_integer_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_optional_integer_updated(self, handler: Callable[[Optional[int]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_integer' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_optional_integer_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_two_integers_updated(self, handler: Callable[[int, Optional[int]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_integers' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_two_integers_property_callbacks.append(wrapper)
        return wrapper

    def on_read_only_string_updated(self, handler: Callable[[str], None]):
        """This method registers a callback to be called whenever a new 'read_only_string' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_only_string_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_string_updated(self, handler: Callable[[str], None]):
        """This method registers a callback to be called whenever a new 'read_write_string' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_string_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_optional_string_updated(self, handler: Callable[[Optional[str]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_string' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_optional_string_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_two_strings_updated(self, handler: Callable[[str, Optional[str]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_strings' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_two_strings_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_struct_updated(self, handler: Callable[[AllTypes], None]):
        """This method registers a callback to be called whenever a new 'read_write_struct' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_struct_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_optional_struct_updated(self, handler: Callable[[AllTypes], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_struct' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_optional_struct_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_two_structs_updated(self, handler: Callable[[AllTypes, AllTypes], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_structs' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_two_structs_property_callbacks.append(wrapper)
        return wrapper

    def on_read_only_enum_updated(self, handler: Callable[[Numbers], None]):
        """This method registers a callback to be called whenever a new 'read_only_enum' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_only_enum_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_enum_updated(self, handler: Callable[[Numbers], None]):
        """This method registers a callback to be called whenever a new 'read_write_enum' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_enum_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_optional_enum_updated(self, handler: Callable[[Optional[Numbers]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_enum' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_optional_enum_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_two_enums_updated(self, handler: Callable[[Numbers, Optional[Numbers]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_enums' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_two_enums_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_datetime_updated(self, handler: Callable[[datetime], None]):
        """This method registers a callback to be called whenever a new 'read_write_datetime' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_datetime_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_optional_datetime_updated(self, handler: Callable[[Optional[datetime]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_datetime' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_optional_datetime_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_two_datetimes_updated(self, handler: Callable[[datetime, Optional[datetime]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_datetimes' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_two_datetimes_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_duration_updated(self, handler: Callable[[timedelta], None]):
        """This method registers a callback to be called whenever a new 'read_write_duration' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_duration_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_optional_duration_updated(self, handler: Callable[[Optional[timedelta]], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_duration' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_optional_duration_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_two_durations_updated(self, handler: Callable[[timedelta, Optional[timedelta]], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_durations' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_two_durations_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_binary_updated(self, handler: Callable[[bytes], None]):
        """This method registers a callback to be called whenever a new 'read_write_binary' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_binary_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_optional_binary_updated(self, handler: Callable[[bytes], None]):
        """This method registers a callback to be called whenever a new 'read_write_optional_binary' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_optional_binary_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_two_binaries_updated(self, handler: Callable[[bytes, bytes], None]):
        """This method registers a callback to be called whenever a new 'read_write_two_binaries' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_two_binaries_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_list_of_strings_updated(self, handler: Callable[[List[str]], None]):
        """This method registers a callback to be called whenever a new 'read_write_list_of_strings' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_list_of_strings_property_callbacks.append(wrapper)
        return wrapper

    def on_read_write_lists_updated(self, handler: Callable[[List[Numbers], List[datetime]], None]):
        """This method registers a callback to be called whenever a new 'read_write_lists' property update is received."""

        @functools.wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._read_write_lists_property_callbacks.append(wrapper)
        return wrapper

    def build(self, connection: IBrokerConnection, instance_id: str, property_access: TestablePropertyAccess, binding: Optional[Any] = None) -> TestableServer:
        new_server = TestableServer(connection, instance_id, property_access)

        if self._call_with_nothing_method_handler is not None:
            if binding:
                new_server.handle_call_with_nothing(self._call_with_nothing_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_with_nothing(self._call_with_nothing_method_handler)
        if self._call_one_integer_method_handler is not None:
            if binding:
                new_server.handle_call_one_integer(self._call_one_integer_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_one_integer(self._call_one_integer_method_handler)
        if self._call_optional_integer_method_handler is not None:
            if binding:
                new_server.handle_call_optional_integer(self._call_optional_integer_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_optional_integer(self._call_optional_integer_method_handler)
        if self._call_three_integers_method_handler is not None:
            if binding:
                new_server.handle_call_three_integers(self._call_three_integers_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_three_integers(self._call_three_integers_method_handler)
        if self._call_one_string_method_handler is not None:
            if binding:
                new_server.handle_call_one_string(self._call_one_string_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_one_string(self._call_one_string_method_handler)
        if self._call_optional_string_method_handler is not None:
            if binding:
                new_server.handle_call_optional_string(self._call_optional_string_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_optional_string(self._call_optional_string_method_handler)
        if self._call_three_strings_method_handler is not None:
            if binding:
                new_server.handle_call_three_strings(self._call_three_strings_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_three_strings(self._call_three_strings_method_handler)
        if self._call_one_enum_method_handler is not None:
            if binding:
                new_server.handle_call_one_enum(self._call_one_enum_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_one_enum(self._call_one_enum_method_handler)
        if self._call_optional_enum_method_handler is not None:
            if binding:
                new_server.handle_call_optional_enum(self._call_optional_enum_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_optional_enum(self._call_optional_enum_method_handler)
        if self._call_three_enums_method_handler is not None:
            if binding:
                new_server.handle_call_three_enums(self._call_three_enums_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_three_enums(self._call_three_enums_method_handler)
        if self._call_one_struct_method_handler is not None:
            if binding:
                new_server.handle_call_one_struct(self._call_one_struct_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_one_struct(self._call_one_struct_method_handler)
        if self._call_optional_struct_method_handler is not None:
            if binding:
                new_server.handle_call_optional_struct(self._call_optional_struct_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_optional_struct(self._call_optional_struct_method_handler)
        if self._call_three_structs_method_handler is not None:
            if binding:
                new_server.handle_call_three_structs(self._call_three_structs_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_three_structs(self._call_three_structs_method_handler)
        if self._call_one_date_time_method_handler is not None:
            if binding:
                new_server.handle_call_one_date_time(self._call_one_date_time_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_one_date_time(self._call_one_date_time_method_handler)
        if self._call_optional_date_time_method_handler is not None:
            if binding:
                new_server.handle_call_optional_date_time(self._call_optional_date_time_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_optional_date_time(self._call_optional_date_time_method_handler)
        if self._call_three_date_times_method_handler is not None:
            if binding:
                new_server.handle_call_three_date_times(self._call_three_date_times_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_three_date_times(self._call_three_date_times_method_handler)
        if self._call_one_duration_method_handler is not None:
            if binding:
                new_server.handle_call_one_duration(self._call_one_duration_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_one_duration(self._call_one_duration_method_handler)
        if self._call_optional_duration_method_handler is not None:
            if binding:
                new_server.handle_call_optional_duration(self._call_optional_duration_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_optional_duration(self._call_optional_duration_method_handler)
        if self._call_three_durations_method_handler is not None:
            if binding:
                new_server.handle_call_three_durations(self._call_three_durations_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_three_durations(self._call_three_durations_method_handler)
        if self._call_one_binary_method_handler is not None:
            if binding:
                new_server.handle_call_one_binary(self._call_one_binary_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_one_binary(self._call_one_binary_method_handler)
        if self._call_optional_binary_method_handler is not None:
            if binding:
                new_server.handle_call_optional_binary(self._call_optional_binary_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_optional_binary(self._call_optional_binary_method_handler)
        if self._call_three_binaries_method_handler is not None:
            if binding:
                new_server.handle_call_three_binaries(self._call_three_binaries_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_three_binaries(self._call_three_binaries_method_handler)
        if self._call_one_list_of_integers_method_handler is not None:
            if binding:
                new_server.handle_call_one_list_of_integers(self._call_one_list_of_integers_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_one_list_of_integers(self._call_one_list_of_integers_method_handler)
        if self._call_optional_list_of_floats_method_handler is not None:
            if binding:
                new_server.handle_call_optional_list_of_floats(self._call_optional_list_of_floats_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_optional_list_of_floats(self._call_optional_list_of_floats_method_handler)
        if self._call_two_lists_method_handler is not None:
            if binding:
                new_server.handle_call_two_lists(self._call_two_lists_method_handler.__get__(binding, binding.__class__))
            else:
                new_server.handle_call_two_lists(self._call_two_lists_method_handler)

        for read_write_integer_callback in self._read_write_integer_property_callbacks:
            if binding:
                new_server.on_read_write_integer_updated(read_write_integer_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_integer_updated(read_write_integer_callback)

        for read_only_integer_callback in self._read_only_integer_property_callbacks:
            if binding:
                new_server.on_read_only_integer_updated(read_only_integer_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_only_integer_updated(read_only_integer_callback)

        for read_write_optional_integer_callback in self._read_write_optional_integer_property_callbacks:
            if binding:
                new_server.on_read_write_optional_integer_updated(read_write_optional_integer_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_optional_integer_updated(read_write_optional_integer_callback)

        for read_write_two_integers_callback in self._read_write_two_integers_property_callbacks:
            if binding:
                new_server.on_read_write_two_integers_updated(read_write_two_integers_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_two_integers_updated(read_write_two_integers_callback)

        for read_only_string_callback in self._read_only_string_property_callbacks:
            if binding:
                new_server.on_read_only_string_updated(read_only_string_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_only_string_updated(read_only_string_callback)

        for read_write_string_callback in self._read_write_string_property_callbacks:
            if binding:
                new_server.on_read_write_string_updated(read_write_string_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_string_updated(read_write_string_callback)

        for read_write_optional_string_callback in self._read_write_optional_string_property_callbacks:
            if binding:
                new_server.on_read_write_optional_string_updated(read_write_optional_string_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_optional_string_updated(read_write_optional_string_callback)

        for read_write_two_strings_callback in self._read_write_two_strings_property_callbacks:
            if binding:
                new_server.on_read_write_two_strings_updated(read_write_two_strings_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_two_strings_updated(read_write_two_strings_callback)

        for read_write_struct_callback in self._read_write_struct_property_callbacks:
            if binding:
                new_server.on_read_write_struct_updated(read_write_struct_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_struct_updated(read_write_struct_callback)

        for read_write_optional_struct_callback in self._read_write_optional_struct_property_callbacks:
            if binding:
                new_server.on_read_write_optional_struct_updated(read_write_optional_struct_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_optional_struct_updated(read_write_optional_struct_callback)

        for read_write_two_structs_callback in self._read_write_two_structs_property_callbacks:
            if binding:
                new_server.on_read_write_two_structs_updated(read_write_two_structs_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_two_structs_updated(read_write_two_structs_callback)

        for read_only_enum_callback in self._read_only_enum_property_callbacks:
            if binding:
                new_server.on_read_only_enum_updated(read_only_enum_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_only_enum_updated(read_only_enum_callback)

        for read_write_enum_callback in self._read_write_enum_property_callbacks:
            if binding:
                new_server.on_read_write_enum_updated(read_write_enum_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_enum_updated(read_write_enum_callback)

        for read_write_optional_enum_callback in self._read_write_optional_enum_property_callbacks:
            if binding:
                new_server.on_read_write_optional_enum_updated(read_write_optional_enum_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_optional_enum_updated(read_write_optional_enum_callback)

        for read_write_two_enums_callback in self._read_write_two_enums_property_callbacks:
            if binding:
                new_server.on_read_write_two_enums_updated(read_write_two_enums_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_two_enums_updated(read_write_two_enums_callback)

        for read_write_datetime_callback in self._read_write_datetime_property_callbacks:
            if binding:
                new_server.on_read_write_datetime_updated(read_write_datetime_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_datetime_updated(read_write_datetime_callback)

        for read_write_optional_datetime_callback in self._read_write_optional_datetime_property_callbacks:
            if binding:
                new_server.on_read_write_optional_datetime_updated(read_write_optional_datetime_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_optional_datetime_updated(read_write_optional_datetime_callback)

        for read_write_two_datetimes_callback in self._read_write_two_datetimes_property_callbacks:
            if binding:
                new_server.on_read_write_two_datetimes_updated(read_write_two_datetimes_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_two_datetimes_updated(read_write_two_datetimes_callback)

        for read_write_duration_callback in self._read_write_duration_property_callbacks:
            if binding:
                new_server.on_read_write_duration_updated(read_write_duration_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_duration_updated(read_write_duration_callback)

        for read_write_optional_duration_callback in self._read_write_optional_duration_property_callbacks:
            if binding:
                new_server.on_read_write_optional_duration_updated(read_write_optional_duration_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_optional_duration_updated(read_write_optional_duration_callback)

        for read_write_two_durations_callback in self._read_write_two_durations_property_callbacks:
            if binding:
                new_server.on_read_write_two_durations_updated(read_write_two_durations_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_two_durations_updated(read_write_two_durations_callback)

        for read_write_binary_callback in self._read_write_binary_property_callbacks:
            if binding:
                new_server.on_read_write_binary_updated(read_write_binary_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_binary_updated(read_write_binary_callback)

        for read_write_optional_binary_callback in self._read_write_optional_binary_property_callbacks:
            if binding:
                new_server.on_read_write_optional_binary_updated(read_write_optional_binary_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_optional_binary_updated(read_write_optional_binary_callback)

        for read_write_two_binaries_callback in self._read_write_two_binaries_property_callbacks:
            if binding:
                new_server.on_read_write_two_binaries_updated(read_write_two_binaries_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_two_binaries_updated(read_write_two_binaries_callback)

        for read_write_list_of_strings_callback in self._read_write_list_of_strings_property_callbacks:
            if binding:
                new_server.on_read_write_list_of_strings_updated(read_write_list_of_strings_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_list_of_strings_updated(read_write_list_of_strings_callback)

        for read_write_lists_callback in self._read_write_lists_property_callbacks:
            if binding:
                new_server.on_read_write_lists_updated(read_write_lists_callback.__get__(binding, binding.__class__))
            else:
                new_server.on_read_write_lists_updated(read_write_lists_callback)

        return new_server
