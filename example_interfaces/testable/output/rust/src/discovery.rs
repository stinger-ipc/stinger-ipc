/*
DO NOT MODIFY THIS FILE.  It is automatically generated by Stinger-IPC 0.6.13 and changes will be over-written
on the next generation.

This is the Client for the testable interface.

LICENSE: This generated code is not subject to any license restrictions from the generator itself.
TODO: Get license text from stinger file
*/
use std::collections::HashMap;
use std::fmt;
use std::sync::{Arc, RwLock};

use crate::interface::InterfaceInfo;
use stinger_mqtt_trait::message::{MqttMessage, QoS};
use stinger_mqtt_trait::{Mqtt5PubSub, Mqtt5PubSubError};
use tokio::sync::broadcast;
use tokio::task::JoinHandle;
#[allow(unused_imports)]
use tracing::{debug, error, info, warn};

use crate::property::{TestableInitialPropertyValues, TestableInitialPropertyValuesBuilder};

#[allow(unused_imports)]
use crate::payloads::*;
#[cfg(feature = "metrics")]
use std::sync::Mutex;

#[derive(Debug)]
pub enum TestableDiscoveryError {
    Subscribe(Mqtt5PubSubError),
}

impl fmt::Display for TestableDiscoveryError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TestableDiscoveryError::Subscribe(err) => {
                write!(f, "failed to subscribe for discovery: {err}")
            }
        }
    }
}

impl std::error::Error for TestableDiscoveryError {}

impl From<Mqtt5PubSubError> for TestableDiscoveryError {
    fn from(value: Mqtt5PubSubError) -> Self {
        TestableDiscoveryError::Subscribe(value)
    }
}

struct ServiceInDiscovery {
    pub interface_info: Option<InterfaceInfo>,

    pub property_builder: TestableInitialPropertyValuesBuilder,
    pub property_count: u32,

    pub fully_discovered: std::sync::atomic::AtomicBool,
}

impl Default for ServiceInDiscovery {
    fn default() -> Self {
        Self {
            interface_info: None,

            property_builder: TestableInitialPropertyValuesBuilder::default(),
            property_count: 0,

            fully_discovered: std::sync::atomic::AtomicBool::new(false),
        }
    }
}

#[derive(Clone, Debug)]
pub struct DiscoveredService {
    pub interface_info: InterfaceInfo,

    pub properties: TestableInitialPropertyValues,
}

impl ServiceInDiscovery {
    /// Attempts to convert a ServiceInDiscovery into a DiscoveredService
    pub fn to_discovered_service(&self) -> Option<DiscoveredService> {
        let built_properties_result = self.property_builder.build();
        match (&self.interface_info, built_properties_result) {
            (Some(info), Ok(props)) => Some(DiscoveredService {
                interface_info: info.clone(),
                properties: props,
            }),
            _ => None,
        }
    }
}

#[cfg(feature = "metrics")]
#[derive(Debug)]
pub struct TestableDiscoveryMetrics {
    pub discovery_start_time: std::time::Instant,
    pub time_of_first_discovery: Option<std::time::Instant>,
    pub received_property_values: std::sync::atomic::AtomicU32,
}

#[cfg(feature = "metrics")]
impl Default for TestableDiscoveryMetrics {
    fn default() -> Self {
        Self {
            discovery_start_time: std::time::Instant::now(),
            time_of_first_discovery: None,
            received_property_values: std::sync::atomic::AtomicU32::new(0),
        }
    }
}

#[cfg(feature = "metrics")]
impl TestableDiscoveryMetrics {
    /// Sets the time_of_first_discovery if it hasn't been set yet
    pub fn set_time_of_first_discovery(&mut self) {
        if self.time_of_first_discovery.is_none() {
            self.time_of_first_discovery = Some(std::time::Instant::now());
        }
    }

    /// Increments received_property_values by 1
    pub fn increment_received_property_values(&self) {
        self.received_property_values
            .fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    }

    /// Returns the time in milliseconds between `discovery_start_time` and
    /// `time_of_first_discovery`, or `None` if `time_of_first_discovery` is not set.
    pub fn time_to_first_discovery_ms(&self) -> Option<u128> {
        self.time_of_first_discovery
            .as_ref()
            .map(|t| t.duration_since(self.discovery_start_time).as_millis())
    }
}

pub struct TestableDiscovery<C: Mqtt5PubSub + Clone + Send + Sync + 'static> {
    connection: C,
    service_name: String,
    instances_in_discovery: Arc<RwLock<HashMap<String, ServiceInDiscovery>>>,
    info_listener_handle: JoinHandle<()>,

    prop_listener_handle: JoinHandle<()>,

    notification_tx: broadcast::Sender<DiscoveredService>,
    #[cfg(feature = "metrics")]
    pub metrics: Arc<Mutex<TestableDiscoveryMetrics>>,
}

/// Event receiver for new interface discovery notifications
pub type TestableDiscoveryReceiver = broadcast::Receiver<DiscoveredService>;

impl<C: Mqtt5PubSub + Clone + Send + Sync + 'static> TestableDiscovery<C> {
    pub async fn new(connection: &mut C) -> Result<Self, TestableDiscoveryError> {
        let service_name = "testable".to_string();
        let discovery_topic = format!("testable/{}/interface", "+");

        let (info_tx, info_rx) = broadcast::channel::<MqttMessage>(32);
        debug!("Subscribing to discovery topic: {discovery_topic}");
        let _subscription_id = connection
            .subscribe(discovery_topic, QoS::AtLeastOnce, info_tx.clone())
            .await
            .map_err(TestableDiscoveryError::from)?;

        let (prop_tx, prop_rx) = broadcast::channel::<MqttMessage>(32);
        let _property_subscription_id = connection
            .subscribe(
                "testable/+/property/+/value".to_string(),
                QoS::AtLeastOnce,
                prop_tx.clone(),
            )
            .await
            .map_err(TestableDiscoveryError::from)?;

        let instances_in_discovery = Arc::new(RwLock::new(HashMap::new()));

        // Clients can get a notification receiver by calling the subscribe() method.
        let (notification_tx, _notification_rx) = broadcast::channel::<DiscoveredService>(32);

        #[cfg(feature = "metrics")]
        let metrics = Arc::new(Mutex::new(TestableDiscoveryMetrics::default()));

        let info_listener_handle = Self::spawn_listener(
            info_rx,
            instances_in_discovery.clone(),
            notification_tx.clone(),
            #[cfg(feature = "metrics")]
            metrics.clone(),
        );

        let prop_listener_handle = Self::spawn_property_listener(
            prop_rx,
            instances_in_discovery.clone(),
            notification_tx.clone(),
            #[cfg(feature = "metrics")]
            metrics.clone(),
        );

        Ok(Self {
            connection: connection.clone(),
            service_name,
            instances_in_discovery,
            info_listener_handle,

            prop_listener_handle,

            notification_tx,
            #[cfg(feature = "metrics")]
            metrics,
        })
    }

    pub fn service_name(&self) -> &str {
        &self.service_name
    }

    pub fn instances_in_discovery(&self) -> Vec<DiscoveredService> {
        let guard = self
            .instances_in_discovery
            .read()
            .expect("interfaces poisoned");
        guard
            .values()
            .filter(|sd| {
                sd.fully_discovered
                    .load(std::sync::atomic::Ordering::Relaxed)
            })
            .filter_map(|sd| sd.to_discovered_service())
            .collect()
    }

    pub async fn get_singleton_service(&self) -> DiscoveredService {
        // First check if we already have an interface
        {
            let instance_map = self
                .instances_in_discovery
                .read()
                .expect("interfaces poisoned");
            if let Some(entry) = instance_map.values().next() {
                if entry.interface_info.is_some() {
                    let prop_build_result = entry.property_builder.build();
                    if prop_build_result.is_ok() {
                        return DiscoveredService {
                            interface_info: entry.interface_info.clone().unwrap(),

                            properties: prop_build_result.unwrap(),
                        };
                    }
                }
            }
        }

        // No interfaces yet, wait for the first one to be discovered
        let mut receiver = self.notification_tx.subscribe();
        receiver.recv().await.expect("notification channel closed")
    }

    pub fn subscribe(&self) -> TestableDiscoveryReceiver {
        self.notification_tx.subscribe()
    }

    fn try_publish_discovered_service(
        service_in_discovery: &ServiceInDiscovery,
        notification_tx: &broadcast::Sender<DiscoveredService>,
        #[cfg(feature = "metrics")] metrics: &Arc<Mutex<TestableDiscoveryMetrics>>,
    ) {
        // Check if this completes the discovery

        if service_in_discovery.property_count >= 26 {
            if let Some(discovered) = service_in_discovery.to_discovered_service() {
                service_in_discovery
                    .fully_discovered
                    .store(true, std::sync::atomic::Ordering::Relaxed);
                let _ = notification_tx.send(discovered);
                #[cfg(feature = "metrics")]
                {
                    let mut metrics_guard = metrics.lock().unwrap();
                    metrics_guard.set_time_of_first_discovery();
                }
            }
        }
    }

    fn spawn_listener(
        mut message_rx: broadcast::Receiver<MqttMessage>,
        instances_in_discovery: Arc<RwLock<HashMap<String, ServiceInDiscovery>>>,
        notification_tx: broadcast::Sender<DiscoveredService>,
        #[cfg(feature = "metrics")] metrics: Arc<Mutex<TestableDiscoveryMetrics>>,
    ) -> JoinHandle<()> {
        tokio::spawn(async move {
            debug!("Listening for discovery messages");
            while let Ok(message) = message_rx.recv().await {
                Self::handle_message(
                    message,
                    &instances_in_discovery,
                    &notification_tx,
                    #[cfg(feature = "metrics")]
                    metrics.clone(),
                );
            }
        })
    }

    fn spawn_property_listener(
        mut message_rx: broadcast::Receiver<MqttMessage>,
        instances_in_discovery: Arc<RwLock<HashMap<String, ServiceInDiscovery>>>,
        notification_tx: broadcast::Sender<DiscoveredService>,
        #[cfg(feature = "metrics")] metrics: Arc<Mutex<TestableDiscoveryMetrics>>,
    ) -> JoinHandle<()> {
        tokio::spawn(async move {
            debug!("Listening for property value messages");
            while let Ok(message) = message_rx.recv().await {
                #[cfg(feature = "metrics")]
                {
                    let metrics_guard = metrics.lock().unwrap();
                    metrics_guard.increment_received_property_values();
                }

                // Parse property topic (format: service/{instance_id}/property/{property_name}/value)
                let topic_parts: Vec<&str> = message.topic.split('/').collect();
                if topic_parts.len() == 5 {
                    let instance_id = topic_parts[1];
                    let property_name = topic_parts[3];

                    let mut instance_map = instances_in_discovery
                        .write()
                        .expect("interfaces write lock poisoned");
                    let service_in_discovery =
                        instance_map.entry(instance_id.to_string()).or_default();

                    match property_name {
                        "readWriteInteger" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteIntegerProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_integer(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_integer_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_integer' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readOnlyInteger" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadOnlyIntegerProperty>(&message.payload);

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_only_integer(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_only_integer_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_only_integer' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteOptionalInteger" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteOptionalIntegerProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_integer(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_integer_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_optional_integer' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteTwoIntegers" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteTwoIntegersProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_integers(prop_value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_integers_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_two_integers' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readOnlyString" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadOnlyStringProperty>(&message.payload);

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_only_string(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_only_string_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_only_string' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteString" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteStringProperty>(&message.payload);

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_string(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_string_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_string' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteOptionalString" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteOptionalStringProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_string(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_string_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_optional_string' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteTwoStrings" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteTwoStringsProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_strings(prop_value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_strings_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_two_strings' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteStruct" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteStructProperty>(&message.payload);

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_struct(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_struct_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_struct' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteOptionalStruct" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteOptionalStructProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_struct(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_struct_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_optional_struct' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteTwoStructs" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteTwoStructsProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_structs(prop_value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_structs_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_two_structs' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readOnlyEnum" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadOnlyEnumProperty>(&message.payload);

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_only_enum(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_only_enum_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_only_enum' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteEnum" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteEnumProperty>(&message.payload);

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_enum(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_enum_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_enum' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteOptionalEnum" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteOptionalEnumProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_enum(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_enum_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_optional_enum' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteTwoEnums" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteTwoEnumsProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_enums(prop_value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_enums_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_two_enums' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteDatetime" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteDatetimeProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_datetime(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_datetime_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_datetime' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteOptionalDatetime" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteOptionalDatetimeProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_datetime(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_datetime_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_optional_datetime' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteTwoDatetimes" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteTwoDatetimesProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_datetimes(prop_value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_datetimes_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_two_datetimes' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteDuration" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteDurationProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_duration(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_duration_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_duration' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteOptionalDuration" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteOptionalDurationProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_duration(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_duration_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_optional_duration' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteTwoDurations" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteTwoDurationsProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_durations(prop_value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_durations_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_two_durations' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteBinary" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteBinaryProperty>(&message.payload);

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_binary(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_binary_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_binary' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteOptionalBinary" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteOptionalBinaryProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_binary(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_optional_binary_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_optional_binary' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteTwoBinaries" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteTwoBinariesProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_binaries(prop_value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_two_binaries_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_two_binaries' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteListOfStrings" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteListOfStringsProperty>(
                                    &message.payload,
                                );

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_list_of_strings(prop_value.value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_list_of_strings_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_list_of_strings' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        "readWriteLists" => {
                            let deserialized_property =
                                serde_json::from_slice::<ReadWriteListsProperty>(&message.payload);

                            let version = message
                                .user_properties
                                .get("PropertyVersion")
                                .and_then(|v| v.parse::<u32>().ok())
                                .unwrap_or(0);
                            match deserialized_property {
                                Ok(prop_value) => {
                                    service_in_discovery
                                        .property_builder
                                        .read_write_lists(prop_value);

                                    service_in_discovery
                                        .property_builder
                                        .read_write_lists_version(version);
                                    service_in_discovery.property_count += 1;
                                }
                                Err(e) => {
                                    error!("Failed to deserialize property 'read_write_lists' for instance '{}': {}", instance_id, e);
                                }
                            }
                        }

                        _ => {
                            // Ignore unknown properties
                        }
                    }
                    Self::try_publish_discovered_service(
                        service_in_discovery,
                        &notification_tx,
                        #[cfg(feature = "metrics")]
                        &metrics,
                    );
                }
            }
        })
    }

    fn handle_message(
        message: MqttMessage,
        instances_in_discovery: &Arc<RwLock<HashMap<String, ServiceInDiscovery>>>,
        notification_tx: &broadcast::Sender<DiscoveredService>,
        #[cfg(feature = "metrics")] metrics: Arc<Mutex<TestableDiscoveryMetrics>>,
    ) {
        if message.payload.is_empty() {
            info!("Service represented by {} is now offline", message.topic);
            // Parse instance_id from topic (format: full/{instance_id}/interface)
            let topic_parts: Vec<&str> = message.topic.split('/').collect();
            if topic_parts.len() >= 2 {
                let instance_id = topic_parts[topic_parts.len() - 2].to_string();
                let mut interfaces_guard = instances_in_discovery
                    .write()
                    .expect("interfaces write lock poisoned");
                interfaces_guard.remove(&instance_id);
                drop(interfaces_guard);
            }
        } else {
            let deserialized = serde_json::from_slice::<InterfaceInfo>(&message.payload);
            match deserialized {
                Ok(info) => {
                    info!("Discovered service instance: {:?}", info);
                    {
                        let mut instance_map = instances_in_discovery
                            .write()
                            .expect("interfaces write lock poisoned");
                        let service_in_discovery =
                            instance_map.entry(info.instance.clone()).or_default();
                        service_in_discovery.interface_info = Some(info);
                        Self::try_publish_discovered_service(
                            service_in_discovery,
                            notification_tx,
                            #[cfg(feature = "metrics")]
                            &metrics,
                        );
                    }
                }
                Err(err) => {
                    error!(
                        "Failed to deserialize InterfaceInfo from {}: {}",
                        message.topic, err
                    );
                }
            }
        }
    }
}

impl<C: Mqtt5PubSub + Clone + Send + Sync + 'static> Drop for TestableDiscovery<C> {
    fn drop(&mut self) {
        self.info_listener_handle.abort();
        let _ = self
            .connection
            .unsubscribe(format!("testable/{}/interface", "+"));

        self.prop_listener_handle.abort();
        let _ = self
            .connection
            .unsubscribe("testable/+/property/+/value".to_string());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_message(topic: &str, instance: &str) -> MqttMessage {
        let info = InterfaceInfo {
            interface_name: "sample".into(),
            title: "Sample".into(),
            version: "1.0".into(),
            instance: instance.into(),
            connection_topic: format!("sample/{instance}"),
            timestamp: "2024-01-01T00:00:00Z".into(),
        };
        let payload = serde_json::to_vec(&info).expect("serialize");

        MqttMessage {
            topic: topic.into(),
            payload,
            qos: 1,
            subscription_id: 42,
            response_topic: None,
            content_type: None,
            correlation_data: None,
            user_properties: HashMap::new(),
        }
    }

    #[tokio::test]
    async fn collects_unique_instances_and_topics() {
        let interfaces = Arc::new(RwLock::new(HashMap::new()));
        let (notification_tx, mut notification_rx) = broadcast::channel::<InterfaceInfo>(32);

        TestableDiscovery::handle_message(
            sample_message("service/alpha/interface", "alpha"),
            &interfaces,
            &notification_tx,
        );
        TestableDiscovery::handle_message(
            sample_message("service/beta/interface", "beta"),
            &interfaces,
            &notification_tx,
        );
        TestableDiscovery::handle_message(
            sample_message("service/alpha/interface", "alpha"),
            &interfaces,
            &notification_tx,
        );

        let interfaces_guard = interfaces.read().unwrap();
        assert_eq!(interfaces_guard.len(), 2);
        assert!(interfaces_guard.contains_key("alpha"));
        assert!(interfaces_guard.contains_key("beta"));

        // Check that we received exactly 2 notifications (only for new interfaces)
        let info1 = notification_rx
            .try_recv()
            .expect("should have first notification");
        assert_eq!(info1.instance, "alpha");
        let info2 = notification_rx
            .try_recv()
            .expect("should have second notification");
        assert_eq!(info2.instance, "beta");
        assert!(
            notification_rx.try_recv().is_err(),
            "should not have third notification"
        );
    }
}
