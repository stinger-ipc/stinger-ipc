"""
DO NOT MODIFY THIS FILE.  It is automatically generated by Stinger-IPC 0.6.21 and changes will be over-written
on the next generation.

This is the Client for the Full interface.

LICENSE: This generated code is not subject to any license restrictions from the generator itself.
TODO: Get license text from stinger file
"""

from typing import Dict, Callable, List, Any, Optional, Union
from uuid import uuid4
from functools import partial, wraps
import json
import logging
from datetime import datetime, timedelta, UTC

from isodate import parse_duration
from stinger_python_utils.message_creator import MessageCreator
from pyqttier.interface import IBrokerConnection
from pyqttier.message import Message
import concurrent.futures as futures
import asyncio
import threading
from stinger_python_utils.return_codes import (
    MethodReturnCode,
    ClientDeserializationErrorStingerMethodException,
    stinger_exception_factory,
)
from .interface_types import *

from .property import FullInitialPropertyValues

from pydantic import BaseModel

logging.basicConfig(level=logging.DEBUG)

TodayIsSignalCallbackType = Union[Callable[[int, DayOfTheWeek], None], Callable[[Any, int, DayOfTheWeek], None]]
RandomWordSignalCallbackType = Union[Callable[[str, datetime], None], Callable[[Any, str, datetime], None]]
AddNumbersMethodResponseCallbackType = Union[Callable[[int], None], Callable[[Any, int], None]]
DoSomethingMethodResponseCallbackType = Union[Callable[[DoSomethingMethodResponse], None], Callable[[Any, DoSomethingMethodResponse], None]]
WhatTimeIsItMethodResponseCallbackType = Union[Callable[[datetime], None], Callable[[Any, datetime], None]]
HoldTemperatureMethodResponseCallbackType = Union[Callable[[bool], None], Callable[[Any, bool], None]]

FavoriteNumberPropertyUpdatedCallbackType = Union[Callable[[int], None], Callable[[Any, int], None]]
FavoriteFoodsPropertyUpdatedCallbackType = Union[Callable[[FavoriteFoodsProperty], None], Callable[[Any, FavoriteFoodsProperty], None]]
LunchMenuPropertyUpdatedCallbackType = Union[Callable[[LunchMenuProperty], None], Callable[[Any, LunchMenuProperty], None]]
FamilyNamePropertyUpdatedCallbackType = Union[Callable[[str], None], Callable[[Any, str], None]]
LastBreakfastTimePropertyUpdatedCallbackType = Union[Callable[[datetime], None], Callable[[Any, datetime], None]]
LastBirthdaysPropertyUpdatedCallbackType = Union[Callable[[LastBirthdaysProperty], None], Callable[[Any, LastBirthdaysProperty], None]]


class DiscoveredInstance(BaseModel):
    instance_id: str
    initial_property_values: FullInitialPropertyValues


class FullClient:

    def __init__(self, connection: IBrokerConnection, instance_info: DiscoveredInstance):
        """Constructor for a `FullClient` object."""
        self._logger = logging.getLogger("FullClient")
        self._logger.setLevel(logging.DEBUG)
        self._logger.debug("Initializing FullClient with %s", instance_info.initial_property_values)
        self._conn = connection
        self._conn.add_message_callback(self._receive_message)
        self._service_id = instance_info.instance_id

        self._pending_method_responses: Dict[str, Callable[..., None]] = {}

        self._property_favorite_number = instance_info.initial_property_values.favorite_number  # type: int
        self._property_favorite_number_mutex = threading.Lock()
        self._property_favorite_number_version = instance_info.initial_property_values.favorite_number_version
        self._conn.subscribe("full/{}/property/favoriteNumber/value".format(self._service_id), self._receive_favorite_number_property_update_message)
        self._changed_value_callbacks_for_favorite_number: List[FavoriteNumberPropertyUpdatedCallbackType] = []
        self._property_favorite_foods = instance_info.initial_property_values.favorite_foods  # type: FavoriteFoodsProperty
        self._property_favorite_foods_mutex = threading.Lock()
        self._property_favorite_foods_version = instance_info.initial_property_values.favorite_foods_version
        self._conn.subscribe("full/{}/property/favoriteFoods/value".format(self._service_id), self._receive_favorite_foods_property_update_message)
        self._changed_value_callbacks_for_favorite_foods: List[FavoriteFoodsPropertyUpdatedCallbackType] = []
        self._property_lunch_menu = instance_info.initial_property_values.lunch_menu  # type: LunchMenuProperty
        self._property_lunch_menu_mutex = threading.Lock()
        self._property_lunch_menu_version = instance_info.initial_property_values.lunch_menu_version
        self._conn.subscribe("full/{}/property/lunchMenu/value".format(self._service_id), self._receive_lunch_menu_property_update_message)
        self._changed_value_callbacks_for_lunch_menu: List[LunchMenuPropertyUpdatedCallbackType] = []
        self._property_family_name = instance_info.initial_property_values.family_name  # type: str
        self._property_family_name_mutex = threading.Lock()
        self._property_family_name_version = instance_info.initial_property_values.family_name_version
        self._conn.subscribe("full/{}/property/familyName/value".format(self._service_id), self._receive_family_name_property_update_message)
        self._changed_value_callbacks_for_family_name: List[FamilyNamePropertyUpdatedCallbackType] = []
        self._property_last_breakfast_time = instance_info.initial_property_values.last_breakfast_time  # type: datetime
        self._property_last_breakfast_time_mutex = threading.Lock()
        self._property_last_breakfast_time_version = instance_info.initial_property_values.last_breakfast_time_version
        self._conn.subscribe("full/{}/property/lastBreakfastTime/value".format(self._service_id), self._receive_last_breakfast_time_property_update_message)
        self._changed_value_callbacks_for_last_breakfast_time: List[LastBreakfastTimePropertyUpdatedCallbackType] = []
        self._property_last_birthdays = instance_info.initial_property_values.last_birthdays  # type: LastBirthdaysProperty
        self._property_last_birthdays_mutex = threading.Lock()
        self._property_last_birthdays_version = instance_info.initial_property_values.last_birthdays_version
        self._conn.subscribe("full/{}/property/lastBirthdays/value".format(self._service_id), self._receive_last_birthdays_property_update_message)
        self._changed_value_callbacks_for_last_birthdays: List[LastBirthdaysPropertyUpdatedCallbackType] = []
        self._signal_recv_callbacks_for_today_is: List[TodayIsSignalCallbackType] = []
        self._signal_recv_callbacks_for_random_word: List[RandomWordSignalCallbackType] = []
        self._conn.subscribe(f"client/{self._conn.client_id}/Full/methodResponse", self._receive_any_method_response_message)

        self._property_response_topic = f"client/{self._conn.client_id}/Full/propertyUpdateResponse"
        self._conn.subscribe(self._property_response_topic, self._receive_any_property_response_message)

    @property
    def service_id(self) -> str:
        """The service ID of the connected service instance."""
        return self._service_id

    @property
    def favorite_number(self) -> int:
        """Property 'favorite_number' getter."""
        with self._property_favorite_number_mutex:
            return self._property_favorite_number

    @favorite_number.setter
    def favorite_number(self, value: int):
        """Serializes and publishes the 'favorite_number' property."""
        if not isinstance(value, int):
            raise ValueError("The 'favorite_number' property must be a int.")
        property_obj = FavoriteNumberProperty(number=value)
        self._logger.debug("Setting 'favorite_number' property to %s", property_obj)
        with self._property_favorite_number_mutex:
            req_msg = MessageCreator.property_update_request_message(
                "full/{}/property/favoriteNumber/setValue".format(self._service_id), property_obj, str(self._property_favorite_number_version), self._property_response_topic, str(uuid4())
            )
            self._conn.publish(req_msg)

    def favorite_number_changed(self, handler: FavoriteNumberPropertyUpdatedCallbackType, call_immediately: bool = False):
        """Sets a callback to be called when the 'favorite_number' property changes.
        Can be used as a decorator.
        """
        with self._property_favorite_number_mutex:
            self._changed_value_callbacks_for_favorite_number.append(handler)
            if call_immediately and self._property_favorite_number is not None:
                handler(self._property_favorite_number)  # type: ignore[call-arg]
        return handler

    @property
    def favorite_foods(self) -> FavoriteFoodsProperty:
        """Property 'favorite_foods' getter."""
        with self._property_favorite_foods_mutex:
            return self._property_favorite_foods

    @favorite_foods.setter
    def favorite_foods(self, value: FavoriteFoodsProperty):
        """Serializes and publishes the 'favorite_foods' property."""
        if not isinstance(value, FavoriteFoodsProperty):
            raise ValueError("The 'favorite_foods' property must be a FavoriteFoodsProperty.")
        property_obj = value
        self._logger.debug("Setting 'favorite_foods' property to %s", property_obj)
        with self._property_favorite_foods_mutex:
            req_msg = MessageCreator.property_update_request_message(
                "full/{}/property/favoriteFoods/setValue".format(self._service_id), property_obj, str(self._property_favorite_foods_version), self._property_response_topic, str(uuid4())
            )
            self._conn.publish(req_msg)

    def favorite_foods_changed(self, handler: FavoriteFoodsPropertyUpdatedCallbackType, call_immediately: bool = False):
        """Sets a callback to be called when the 'favorite_foods' property changes.
        Can be used as a decorator.
        """
        with self._property_favorite_foods_mutex:
            self._changed_value_callbacks_for_favorite_foods.append(handler)
            if call_immediately and self._property_favorite_foods is not None:
                handler(self._property_favorite_foods)  # type: ignore[call-arg]
        return handler

    @property
    def lunch_menu(self) -> LunchMenuProperty:
        """Property 'lunch_menu' getter."""
        with self._property_lunch_menu_mutex:
            return self._property_lunch_menu

    def lunch_menu_changed(self, handler: LunchMenuPropertyUpdatedCallbackType, call_immediately: bool = False):
        """Sets a callback to be called when the 'lunch_menu' property changes.
        Can be used as a decorator.
        """
        with self._property_lunch_menu_mutex:
            self._changed_value_callbacks_for_lunch_menu.append(handler)
            if call_immediately and self._property_lunch_menu is not None:
                handler(self._property_lunch_menu)  # type: ignore[call-arg]
        return handler

    @property
    def family_name(self) -> str:
        """Property 'family_name' getter."""
        with self._property_family_name_mutex:
            return self._property_family_name

    @family_name.setter
    def family_name(self, value: str):
        """Serializes and publishes the 'family_name' property."""
        if not isinstance(value, str):
            raise ValueError("The 'family_name' property must be a str.")
        property_obj = FamilyNameProperty(family_name=value)
        self._logger.debug("Setting 'family_name' property to %s", property_obj)
        with self._property_family_name_mutex:
            req_msg = MessageCreator.property_update_request_message(
                "full/{}/property/familyName/setValue".format(self._service_id), property_obj, str(self._property_family_name_version), self._property_response_topic, str(uuid4())
            )
            self._conn.publish(req_msg)

    def family_name_changed(self, handler: FamilyNamePropertyUpdatedCallbackType, call_immediately: bool = False):
        """Sets a callback to be called when the 'family_name' property changes.
        Can be used as a decorator.
        """
        with self._property_family_name_mutex:
            self._changed_value_callbacks_for_family_name.append(handler)
            if call_immediately and self._property_family_name is not None:
                handler(self._property_family_name)  # type: ignore[call-arg]
        return handler

    @property
    def last_breakfast_time(self) -> datetime:
        """Property 'last_breakfast_time' getter."""
        with self._property_last_breakfast_time_mutex:
            return self._property_last_breakfast_time

    @last_breakfast_time.setter
    def last_breakfast_time(self, value: datetime):
        """Serializes and publishes the 'last_breakfast_time' property."""
        if not isinstance(value, datetime):
            raise ValueError("The 'last_breakfast_time' property must be a datetime.")
        property_obj = LastBreakfastTimeProperty(timestamp=value)
        self._logger.debug("Setting 'last_breakfast_time' property to %s", property_obj)
        with self._property_last_breakfast_time_mutex:
            req_msg = MessageCreator.property_update_request_message(
                "full/{}/property/lastBreakfastTime/setValue".format(self._service_id), property_obj, str(self._property_last_breakfast_time_version), self._property_response_topic, str(uuid4())
            )
            self._conn.publish(req_msg)

    def last_breakfast_time_changed(self, handler: LastBreakfastTimePropertyUpdatedCallbackType, call_immediately: bool = False):
        """Sets a callback to be called when the 'last_breakfast_time' property changes.
        Can be used as a decorator.
        """
        with self._property_last_breakfast_time_mutex:
            self._changed_value_callbacks_for_last_breakfast_time.append(handler)
            if call_immediately and self._property_last_breakfast_time is not None:
                handler(self._property_last_breakfast_time)  # type: ignore[call-arg]
        return handler

    @property
    def last_birthdays(self) -> LastBirthdaysProperty:
        """Property 'last_birthdays' getter."""
        with self._property_last_birthdays_mutex:
            return self._property_last_birthdays

    @last_birthdays.setter
    def last_birthdays(self, value: LastBirthdaysProperty):
        """Serializes and publishes the 'last_birthdays' property."""
        if not isinstance(value, LastBirthdaysProperty):
            raise ValueError("The 'last_birthdays' property must be a LastBirthdaysProperty.")
        property_obj = value
        self._logger.debug("Setting 'last_birthdays' property to %s", property_obj)
        with self._property_last_birthdays_mutex:
            req_msg = MessageCreator.property_update_request_message(
                "full/{}/property/lastBirthdays/setValue".format(self._service_id), property_obj, str(self._property_last_birthdays_version), self._property_response_topic, str(uuid4())
            )
            self._conn.publish(req_msg)

    def last_birthdays_changed(self, handler: LastBirthdaysPropertyUpdatedCallbackType, call_immediately: bool = False):
        """Sets a callback to be called when the 'last_birthdays' property changes.
        Can be used as a decorator.
        """
        with self._property_last_birthdays_mutex:
            self._changed_value_callbacks_for_last_birthdays.append(handler)
            if call_immediately and self._property_last_birthdays is not None:
                handler(self._property_last_birthdays)  # type: ignore[call-arg]
        return handler

    def _do_callbacks_for(self, callbacks: List[Callable[..., None]], **kwargs):
        """Call each callback in the callback dictionary with the provided args."""
        for cb in callbacks:
            cb(**kwargs)

    @staticmethod
    def _filter_for_args(args: Dict[str, Any], allowed_args: List[str]) -> Dict[str, Any]:
        """Given a dictionary, reduce the dictionary so that it only has keys in the allowed list."""
        filtered_args = {}
        for k, v in args.items():
            if k in allowed_args:
                filtered_args[k] = v
        return filtered_args

    def _receive_today_is_signal_message(self, message: Message):
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'todayIs' signal with non-JSON content type")
            return

        model = TodayIsSignalPayload.model_validate_json(message.payload)
        kwargs = model.model_dump()

        self._do_callbacks_for(self._signal_recv_callbacks_for_today_is, **kwargs)

    def _receive_random_word_signal_message(self, message: Message):
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'randomWord' signal with non-JSON content type")
            return

        model = RandomWordSignalPayload.model_validate_json(message.payload)
        kwargs = model.model_dump()

        self._do_callbacks_for(self._signal_recv_callbacks_for_random_word, **kwargs)

    def _receive_any_method_response_message(self, message: Message):
        # Handle '' method response.
        return_code = MethodReturnCode.SUCCESS
        debug_message = None
        if message.user_properties:
            user_properties = message.user_properties or {}
            if "DebugInfo" in user_properties:
                self._logger.info("Received Debug Info to '%s': %s", message.topic, user_properties["DebugInfo"])
                debug_message = user_properties["DebugInfo"]
            if "ReturnCode" in user_properties:
                return_code = MethodReturnCode(int(user_properties["ReturnCode"]))
        if message.correlation_data is not None:
            correlation_id = message.correlation_data.decode()
            if correlation_id in self._pending_method_responses:
                cb = self._pending_method_responses[correlation_id]
                del self._pending_method_responses[correlation_id]
                cb(message.payload, return_code, debug_message)
            else:
                self._logger.warning("Correlation id %s was not in the list of pending method responses... %s", correlation_id, [k for k in self._pending_method_responses.keys()])
        else:
            self._logger.warning("No correlation data in properties sent to %s.", message.topic)

    def _receive_any_property_response_message(self, message: Message):
        user_properties = message.user_properties or {}
        return_code = user_properties.get("ReturnCode")
        if return_code is not None and int(return_code) != MethodReturnCode.SUCCESS.value:
            debug_info = user_properties.get("DebugInfo", "")
            self._logger.warning("Received error return value %s from property update: %s", return_code, debug_info)

    def _receive_favorite_number_property_update_message(self, message: Message):
        # Handle 'favorite_number' property change.
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'favorite_number' property change with non-JSON content type")
            return
        try:
            prop_obj = FavoriteNumberProperty.model_validate_json(message.payload)
            user_properties = message.user_properties or {}
            property_version = int(user_properties.get("PropertyVersion", -1))
            with self._property_favorite_number_mutex:
                self._property_favorite_number = prop_obj.number
                self._property_favorite_number_version = property_version

                self._do_callbacks_for(self._changed_value_callbacks_for_favorite_number, value=prop_obj.number)

        except Exception as e:
            self._logger.exception("Error processing 'favorite_number' property change: %s", exc_info=e)

    def _receive_favorite_foods_property_update_message(self, message: Message):
        # Handle 'favorite_foods' property change.
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'favorite_foods' property change with non-JSON content type")
            return
        try:
            prop_obj = FavoriteFoodsProperty.model_validate_json(message.payload)
            user_properties = message.user_properties or {}
            property_version = int(user_properties.get("PropertyVersion", -1))
            with self._property_favorite_foods_mutex:
                self._property_favorite_foods = prop_obj
                self._property_favorite_foods_version = property_version

                self._do_callbacks_for(self._changed_value_callbacks_for_favorite_foods, value=prop_obj)

        except Exception as e:
            self._logger.exception("Error processing 'favorite_foods' property change: %s", exc_info=e)

    def _receive_lunch_menu_property_update_message(self, message: Message):
        # Handle 'lunch_menu' property change.
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'lunch_menu' property change with non-JSON content type")
            return
        try:
            prop_obj = LunchMenuProperty.model_validate_json(message.payload)
            user_properties = message.user_properties or {}
            property_version = int(user_properties.get("PropertyVersion", -1))
            with self._property_lunch_menu_mutex:
                self._property_lunch_menu = prop_obj
                self._property_lunch_menu_version = property_version

                self._do_callbacks_for(self._changed_value_callbacks_for_lunch_menu, value=prop_obj)

        except Exception as e:
            self._logger.exception("Error processing 'lunch_menu' property change: %s", exc_info=e)

    def _receive_family_name_property_update_message(self, message: Message):
        # Handle 'family_name' property change.
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'family_name' property change with non-JSON content type")
            return
        try:
            prop_obj = FamilyNameProperty.model_validate_json(message.payload)
            user_properties = message.user_properties or {}
            property_version = int(user_properties.get("PropertyVersion", -1))
            with self._property_family_name_mutex:
                self._property_family_name = prop_obj.family_name
                self._property_family_name_version = property_version

                self._do_callbacks_for(self._changed_value_callbacks_for_family_name, value=prop_obj.family_name)

        except Exception as e:
            self._logger.exception("Error processing 'family_name' property change: %s", exc_info=e)

    def _receive_last_breakfast_time_property_update_message(self, message: Message):
        # Handle 'last_breakfast_time' property change.
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'last_breakfast_time' property change with non-JSON content type")
            return
        try:
            prop_obj = LastBreakfastTimeProperty.model_validate_json(message.payload)
            user_properties = message.user_properties or {}
            property_version = int(user_properties.get("PropertyVersion", -1))
            with self._property_last_breakfast_time_mutex:
                self._property_last_breakfast_time = prop_obj.timestamp
                self._property_last_breakfast_time_version = property_version

                self._do_callbacks_for(self._changed_value_callbacks_for_last_breakfast_time, value=prop_obj.timestamp)

        except Exception as e:
            self._logger.exception("Error processing 'last_breakfast_time' property change: %s", exc_info=e)

    def _receive_last_birthdays_property_update_message(self, message: Message):
        # Handle 'last_birthdays' property change.
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'last_birthdays' property change with non-JSON content type")
            return
        try:
            prop_obj = LastBirthdaysProperty.model_validate_json(message.payload)
            user_properties = message.user_properties or {}
            property_version = int(user_properties.get("PropertyVersion", -1))
            with self._property_last_birthdays_mutex:
                self._property_last_birthdays = prop_obj
                self._property_last_birthdays_version = property_version

                self._do_callbacks_for(self._changed_value_callbacks_for_last_birthdays, value=prop_obj)

        except Exception as e:
            self._logger.exception("Error processing 'last_birthdays' property change: %s", exc_info=e)

    def _receive_message(self, message: Message):
        """New MQTT messages are passed to this method, which, based on the topic,
        calls the appropriate handler method for the message.
        """
        self._logger.warning("Receiving message %s, but without a handler", message)

    def receive_today_is(self, handler: TodayIsSignalCallbackType):
        """Used as a decorator for methods which handle particular signals."""
        self._signal_recv_callbacks_for_today_is.append(handler)
        if len(self._signal_recv_callbacks_for_today_is) == 1:
            self._conn.subscribe("full/{}/signal/todayIs".format(self._service_id), self._receive_today_is_signal_message)
        return handler

    def receive_random_word(self, handler: RandomWordSignalCallbackType):
        """Used as a decorator for methods which handle particular signals."""
        self._signal_recv_callbacks_for_random_word.append(handler)
        if len(self._signal_recv_callbacks_for_random_word) == 1:
            self._conn.subscribe("full/{}/signal/randomWord".format(self._service_id), self._receive_random_word_signal_message)
        return handler

    def add_numbers(self, first: int, second: int, third: Optional[int]) -> futures.Future:
        """Calling this initiates a `addNumbers` IPC method call."""
        fut = futures.Future()  # type: futures.Future
        correlation_id = str(uuid4())
        self._pending_method_responses[correlation_id] = partial(self._handle_add_numbers_response, fut)
        payload = AddNumbersMethodRequest(
            first=first,
            second=second,
            third=third,
        )
        self._logger.debug("Calling 'addNumbers' method with payload %s", payload)
        response_topic = f"client/{self._conn.client_id}/Full/methodResponse"
        req_msg = MessageCreator.request_message("full/{}/method/addNumbers".format(self._service_id), payload, response_topic, correlation_id)
        self._conn.publish(req_msg)
        return fut

    def _handle_add_numbers_response(self, fut: futures.Future, response_json_text: str, return_value: MethodReturnCode, debug_message: Optional[str] = None):
        """This called with the response to a `addNumbers` IPC method call."""
        self._logger.debug("Handling add_numbers response message %s", fut)

        if return_value != MethodReturnCode.SUCCESS.value:
            self._logger.warning("Received error return value %s from 'addNumbers' method: %s", return_value, debug_message)
            fut.set_exception(stinger_exception_factory(return_value, debug_message))
            return

        try:
            resp_model = AddNumbersMethodResponse.model_validate_json(response_json_text)
        except Exception as e:
            fut.set_exception(ClientDeserializationErrorStingerMethodException(f"Failed to deserialize response to 'addNumbers' method: {e}"))

        if not fut.done():
            fut.set_result(resp_model.sum)
        else:
            self._logger.warning("Future for 'addNumbers' method was already done!")

    def do_something(self, task_to_do: str) -> futures.Future:
        """Calling this initiates a `doSomething` IPC method call."""
        fut = futures.Future()  # type: futures.Future
        correlation_id = str(uuid4())
        self._pending_method_responses[correlation_id] = partial(self._handle_do_something_response, fut)
        payload = DoSomethingMethodRequest(
            task_to_do=task_to_do,
        )
        self._logger.debug("Calling 'doSomething' method with payload %s", payload)
        response_topic = f"client/{self._conn.client_id}/Full/methodResponse"
        req_msg = MessageCreator.request_message("full/{}/method/doSomething".format(self._service_id), payload, response_topic, correlation_id)
        self._conn.publish(req_msg)
        return fut

    def _handle_do_something_response(self, fut: futures.Future, response_json_text: str, return_value: MethodReturnCode, debug_message: Optional[str] = None):
        """This called with the response to a `doSomething` IPC method call."""
        self._logger.debug("Handling do_something response message %s", fut)

        if return_value != MethodReturnCode.SUCCESS.value:
            self._logger.warning("Received error return value %s from 'doSomething' method: %s", return_value, debug_message)
            fut.set_exception(stinger_exception_factory(return_value, debug_message))
            return

        try:
            resp_model = DoSomethingMethodResponse.model_validate_json(response_json_text)
        except Exception as e:
            fut.set_exception(ClientDeserializationErrorStingerMethodException(f"Failed to deserialize response to 'doSomething' method: {e}"))

        if not fut.done():
            fut.set_result(resp_model)
        else:
            self._logger.warning("Future for 'doSomething' method was already done!")

    def what_time_is_it(
        self,
    ) -> futures.Future:
        """Calling this initiates a `what_time_is_it` IPC method call."""
        fut = futures.Future()  # type: futures.Future
        correlation_id = str(uuid4())
        self._pending_method_responses[correlation_id] = partial(self._handle_what_time_is_it_response, fut)
        payload = WhatTimeIsItMethodRequest()
        self._logger.debug("Calling 'what_time_is_it' method with payload %s", payload)
        response_topic = f"client/{self._conn.client_id}/Full/methodResponse"
        req_msg = MessageCreator.request_message("full/{}/method/whatTimeIsIt".format(self._service_id), payload, response_topic, correlation_id)
        self._conn.publish(req_msg)
        return fut

    def _handle_what_time_is_it_response(self, fut: futures.Future, response_json_text: str, return_value: MethodReturnCode, debug_message: Optional[str] = None):
        """This called with the response to a `what_time_is_it` IPC method call."""
        self._logger.debug("Handling what_time_is_it response message %s", fut)

        if return_value != MethodReturnCode.SUCCESS.value:
            self._logger.warning("Received error return value %s from 'what_time_is_it' method: %s", return_value, debug_message)
            fut.set_exception(stinger_exception_factory(return_value, debug_message))
            return

        try:
            resp_model = WhatTimeIsItMethodResponse.model_validate_json(response_json_text)
        except Exception as e:
            fut.set_exception(ClientDeserializationErrorStingerMethodException(f"Failed to deserialize response to 'what_time_is_it' method: {e}"))

        if not fut.done():
            fut.set_result(resp_model.timestamp)
        else:
            self._logger.warning("Future for 'what_time_is_it' method was already done!")

    def hold_temperature(self, temperature_celsius: float) -> futures.Future:
        """Calling this initiates a `hold_temperature` IPC method call."""
        fut = futures.Future()  # type: futures.Future
        correlation_id = str(uuid4())
        self._pending_method_responses[correlation_id] = partial(self._handle_hold_temperature_response, fut)
        payload = HoldTemperatureMethodRequest(
            temperature_celsius=temperature_celsius,
        )
        self._logger.debug("Calling 'hold_temperature' method with payload %s", payload)
        response_topic = f"client/{self._conn.client_id}/Full/methodResponse"
        req_msg = MessageCreator.request_message("full/{}/method/holdTemperature".format(self._service_id), payload, response_topic, correlation_id)
        self._conn.publish(req_msg)
        return fut

    def _handle_hold_temperature_response(self, fut: futures.Future, response_json_text: str, return_value: MethodReturnCode, debug_message: Optional[str] = None):
        """This called with the response to a `hold_temperature` IPC method call."""
        self._logger.debug("Handling hold_temperature response message %s", fut)

        if return_value != MethodReturnCode.SUCCESS.value:
            self._logger.warning("Received error return value %s from 'hold_temperature' method: %s", return_value, debug_message)
            fut.set_exception(stinger_exception_factory(return_value, debug_message))
            return

        try:
            resp_model = HoldTemperatureMethodResponse.model_validate_json(response_json_text)
        except Exception as e:
            fut.set_exception(ClientDeserializationErrorStingerMethodException(f"Failed to deserialize response to 'hold_temperature' method: {e}"))

        if not fut.done():
            fut.set_result(resp_model.success)
        else:
            self._logger.warning("Future for 'hold_temperature' method was already done!")


class FullClientBuilder:
    """Using decorators from FullClient doesn't work if you are trying to create multiple instances of FullClient.
    Instead, use this builder to create a registry of callbacks, and then build clients using the registry.

    When ready to create a FullClient instance, call the `build(broker, service_instance_id)` method.
    """

    def __init__(self):
        """Creates a new FullClientBuilder."""
        self._logger = logging.getLogger("FullClientBuilder")
        self._signal_recv_callbacks_for_today_is = []  # type: List[TodayIsSignalCallbackType]
        self._signal_recv_callbacks_for_random_word = []  # type: List[RandomWordSignalCallbackType]
        self._property_updated_callbacks_for_favorite_number: List[FavoriteNumberPropertyUpdatedCallbackType] = []
        self._property_updated_callbacks_for_favorite_foods: List[FavoriteFoodsPropertyUpdatedCallbackType] = []
        self._property_updated_callbacks_for_lunch_menu: List[LunchMenuPropertyUpdatedCallbackType] = []
        self._property_updated_callbacks_for_family_name: List[FamilyNamePropertyUpdatedCallbackType] = []
        self._property_updated_callbacks_for_last_breakfast_time: List[LastBreakfastTimePropertyUpdatedCallbackType] = []
        self._property_updated_callbacks_for_last_birthdays: List[LastBirthdaysPropertyUpdatedCallbackType] = []

    def receive_today_is(self, handler):
        """Used as a decorator for methods which handle particular signals."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._signal_recv_callbacks_for_today_is.append(wrapper)
        return wrapper

    def receive_random_word(self, handler):
        """Used as a decorator for methods which handle particular signals."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._signal_recv_callbacks_for_random_word.append(wrapper)
        return wrapper

    def favorite_number_updated(self, handler: FavoriteNumberPropertyUpdatedCallbackType):
        """Used as a decorator for methods which handle updates to properties."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._property_updated_callbacks_for_favorite_number.append(wrapper)
        return wrapper

    def favorite_foods_updated(self, handler: FavoriteFoodsPropertyUpdatedCallbackType):
        """Used as a decorator for methods which handle updates to properties."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._property_updated_callbacks_for_favorite_foods.append(wrapper)
        return wrapper

    def lunch_menu_updated(self, handler: LunchMenuPropertyUpdatedCallbackType):
        """Used as a decorator for methods which handle updates to properties."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._property_updated_callbacks_for_lunch_menu.append(wrapper)
        return wrapper

    def family_name_updated(self, handler: FamilyNamePropertyUpdatedCallbackType):
        """Used as a decorator for methods which handle updates to properties."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._property_updated_callbacks_for_family_name.append(wrapper)
        return wrapper

    def last_breakfast_time_updated(self, handler: LastBreakfastTimePropertyUpdatedCallbackType):
        """Used as a decorator for methods which handle updates to properties."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._property_updated_callbacks_for_last_breakfast_time.append(wrapper)
        return wrapper

    def last_birthdays_updated(self, handler: LastBirthdaysPropertyUpdatedCallbackType):
        """Used as a decorator for methods which handle updates to properties."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._property_updated_callbacks_for_last_birthdays.append(wrapper)
        return wrapper

    def build(self, broker: IBrokerConnection, instance_info: DiscoveredInstance, binding: Optional[Any] = None) -> FullClient:
        """Builds a new FullClient."""
        self._logger.debug("Building FullClient for service instance %s", instance_info.instance_id)
        client = FullClient(broker, instance_info)

        for today_is_cb in self._signal_recv_callbacks_for_today_is:
            if binding:
                client.receive_today_is(today_is_cb.__get__(binding, binding.__class__))
            else:
                client.receive_today_is(today_is_cb)

        for random_word_cb in self._signal_recv_callbacks_for_random_word:
            if binding:
                client.receive_random_word(random_word_cb.__get__(binding, binding.__class__))
            else:
                client.receive_random_word(random_word_cb)

        for favorite_number_cb in self._property_updated_callbacks_for_favorite_number:
            if binding:
                client.favorite_number_changed(favorite_number_cb.__get__(binding, binding.__class__))
            else:
                client.favorite_number_changed(favorite_number_cb)

        for favorite_foods_cb in self._property_updated_callbacks_for_favorite_foods:
            if binding:
                client.favorite_foods_changed(favorite_foods_cb.__get__(binding, binding.__class__))
            else:
                client.favorite_foods_changed(favorite_foods_cb)

        for lunch_menu_cb in self._property_updated_callbacks_for_lunch_menu:
            if binding:
                client.lunch_menu_changed(lunch_menu_cb.__get__(binding, binding.__class__))
            else:
                client.lunch_menu_changed(lunch_menu_cb)

        for family_name_cb in self._property_updated_callbacks_for_family_name:
            if binding:
                client.family_name_changed(family_name_cb.__get__(binding, binding.__class__))
            else:
                client.family_name_changed(family_name_cb)

        for last_breakfast_time_cb in self._property_updated_callbacks_for_last_breakfast_time:
            if binding:
                client.last_breakfast_time_changed(last_breakfast_time_cb.__get__(binding, binding.__class__))
            else:
                client.last_breakfast_time_changed(last_breakfast_time_cb)

        for last_birthdays_cb in self._property_updated_callbacks_for_last_birthdays:
            if binding:
                client.last_birthdays_changed(last_birthdays_cb.__get__(binding, binding.__class__))
            else:
                client.last_birthdays_changed(last_birthdays_cb)

        return client


class FullClientDiscoverer:

    def __init__(self, connection: IBrokerConnection, builder: Optional[FullClientBuilder] = None, build_binding: Optional[Any] = None):
        """Creates a new FullClientDiscoverer."""
        self._conn = connection
        self._builder = builder
        self._build_binding = build_binding
        self._logger = logging.getLogger("FullClientDiscoverer")
        self._logger.setLevel(logging.DEBUG)
        service_discovery_topic = "full/{}/interface".format("+")
        self._conn.subscribe(service_discovery_topic, self._process_service_discovery_message)
        self._conn.subscribe("full/+/property/+/value", self._process_property_value_message)
        self._mutex = threading.Lock()
        self._pending_futures: List[futures.Future] = []
        self._removed_service_callbacks: List[Callable[[str], None]] = []

        # For partially discovered services
        self._discovered_interface_infos = dict()  # type: Dict[str, InterfaceInfo]
        self._discovered_properties = dict()  # type: Dict[str, Dict[str, Any]]

        # For fully discovered services
        self._discovered_services: Dict[str, DiscoveredInstance] = {}
        self._discovered_service_callbacks: List[Callable[[DiscoveredInstance], None]] = []

    def add_discovered_service_callback(self, callback: Callable[[DiscoveredInstance], None]):
        """Adds a callback to be called when a new service is discovered."""
        with self._mutex:
            for instance in self._discovered_services.values():
                callback(instance)
            self._discovered_service_callbacks.append(callback)

    def add_removed_service_callback(self, callback: Callable[[str], None]):
        """Adds a callback to be called when a service is removed."""
        with self._mutex:
            self._removed_service_callbacks.append(callback)

    def get_service_instance_ids(self) -> List[str]:
        """Returns a list of currently discovered service instance IDs."""
        with self._mutex:
            return list(self._discovered_services.keys())

    def get_discovery_info(self, instance_id: str) -> Optional[DiscoveredInstance]:
        """Returns the DiscoveredInstance for a discovered service instance ID, or None if not found."""
        with self._mutex:
            return self._discovered_services.get(instance_id, None)

    def get_singleton_client(self) -> futures.Future[FullClient]:
        """Returns a FullClient for the single discovered service.
        Raises an exception if there is not exactly one discovered service.
        """
        fut = futures.Future()  # type: futures.Future[FullClient]
        with self._mutex:
            if len(self._discovered_services) > 0:
                instance_info = next(iter(self._discovered_services.values()))
                if self._builder is None:
                    fut.set_result(FullClient(self._conn, instance_info))
                else:
                    new_client = self._builder.build(self._conn, instance_info, self._build_binding)
                    fut.set_result(new_client)
            else:
                self._pending_futures.append(fut)
        return fut

    def _check_for_fully_discovered(self, instance_id: str):
        """Checks if interface info and all properties have been discovered for the given instance ID."""
        with self._mutex:
            if instance_id in self._discovered_properties and len(self._discovered_properties[instance_id]) == 12 and instance_id in self._discovered_interface_infos:

                entry = DiscoveredInstance(instance_id=instance_id, initial_property_values=FullInitialPropertyValues(**self._discovered_properties[instance_id]))
                is_new_entry = not instance_id in self._discovered_services

                self._discovered_services[instance_id] = entry
                while self._pending_futures:
                    self._logger.info("Creating a client object id=%s and returning as future result", instance_id)
                    fut = self._pending_futures.pop(0)
                    if not fut.done():
                        if self._builder is not None:
                            fut.set_result(self._builder.build(self._conn, entry, self._build_binding))
                        else:
                            fut.set_result(FullClient(self._conn, entry))
                if is_new_entry:
                    self._logger.info("Discovered service: %s", instance_id)
                    for cb in self._discovered_service_callbacks:
                        cb(entry)
                else:
                    self._logger.debug("Updated info for service: %s", instance_id)

    def _process_service_discovery_message(self, message: Message):
        """Processes a service discovery message."""
        self._logger.debug("Processing service discovery message on topic %s", message.topic)
        if len(message.payload) > 0:
            try:
                service_info = InterfaceInfo.model_validate_json(message.payload)
                with self._mutex:
                    self._discovered_interface_infos[service_info.instance] = service_info
            except Exception as e:
                self._logger.warning("Failed to process service discovery message: %s", e)
            self._check_for_fully_discovered(service_info.instance)

        else:  # Empty payload means the service is going away
            instance_id = message.topic.split("/")[-2]
            with self._mutex:
                if instance_id in self._discovered_services:
                    self._logger.info("Service %s is going away", instance_id)
                    if instance_id in self._discovered_services:
                        del self._discovered_services[instance_id]
                    if instance_id in self._discovered_interface_infos:
                        del self._discovered_interface_infos[instance_id]
                    if instance_id in self._discovered_properties:
                        del self._discovered_properties[instance_id]
                    for cb in self._removed_service_callbacks:
                        cb(instance_id)

    def _process_property_value_message(self, message: Message):
        """Processes a property value message for discovery purposes."""
        self._logger.debug("Processing property value message on topic %s", message.topic)
        instance_id = message.topic.split("/")[1]
        property_name = message.topic.split("/")[3]
        user_properties = message.user_properties or {}
        prop_version = user_properties.get("PropertyVersion", "-1")

        with self._mutex:
            if instance_id not in self._discovered_properties:
                self._discovered_properties[instance_id] = dict()

            if property_name == "favoriteNumber":
                try:
                    favorite_number_prop_obj = FavoriteNumberProperty.model_validate_json(message.payload)
                except Exception as e:
                    self._logger.warning("Failed to deserialize property 'favorite_number' value message:\n%s\n%s", message.payload, e)
                    return
                try:
                    self._discovered_properties[instance_id]["favorite_number"] = favorite_number_prop_obj.number
                    self._discovered_properties[instance_id]["favorite_number_version"] = prop_version
                except Exception as e:
                    self._logger.warning("Failed to process property 'favorite_number' value message: %s", e)
                    return

            elif property_name == "favoriteFoods":
                try:
                    favorite_foods_prop_obj = FavoriteFoodsProperty.model_validate_json(message.payload)
                except Exception as e:
                    self._logger.warning("Failed to deserialize property 'favorite_foods' value message:\n%s\n%s", message.payload, e)
                    return
                try:
                    self._discovered_properties[instance_id]["favorite_foods"] = favorite_foods_prop_obj
                    self._discovered_properties[instance_id]["favorite_foods_version"] = prop_version
                except Exception as e:
                    self._logger.warning("Failed to process property 'favorite_foods' value message: %s", e)
                    return

            elif property_name == "lunchMenu":
                try:
                    lunch_menu_prop_obj = LunchMenuProperty.model_validate_json(message.payload)
                except Exception as e:
                    self._logger.warning("Failed to deserialize property 'lunch_menu' value message:\n%s\n%s", message.payload, e)
                    return
                try:
                    self._discovered_properties[instance_id]["lunch_menu"] = lunch_menu_prop_obj
                    self._discovered_properties[instance_id]["lunch_menu_version"] = prop_version
                except Exception as e:
                    self._logger.warning("Failed to process property 'lunch_menu' value message: %s", e)
                    return

            elif property_name == "familyName":
                try:
                    family_name_prop_obj = FamilyNameProperty.model_validate_json(message.payload)
                except Exception as e:
                    self._logger.warning("Failed to deserialize property 'family_name' value message:\n%s\n%s", message.payload, e)
                    return
                try:
                    self._discovered_properties[instance_id]["family_name"] = family_name_prop_obj.family_name
                    self._discovered_properties[instance_id]["family_name_version"] = prop_version
                except Exception as e:
                    self._logger.warning("Failed to process property 'family_name' value message: %s", e)
                    return

            elif property_name == "lastBreakfastTime":
                try:
                    last_breakfast_time_prop_obj = LastBreakfastTimeProperty.model_validate_json(message.payload)
                except Exception as e:
                    self._logger.warning("Failed to deserialize property 'last_breakfast_time' value message:\n%s\n%s", message.payload, e)
                    return
                try:
                    self._discovered_properties[instance_id]["last_breakfast_time"] = last_breakfast_time_prop_obj.timestamp
                    self._discovered_properties[instance_id]["last_breakfast_time_version"] = prop_version
                except Exception as e:
                    self._logger.warning("Failed to process property 'last_breakfast_time' value message: %s", e)
                    return

            elif property_name == "lastBirthdays":
                try:
                    last_birthdays_prop_obj = LastBirthdaysProperty.model_validate_json(message.payload)
                except Exception as e:
                    self._logger.warning("Failed to deserialize property 'last_birthdays' value message:\n%s\n%s", message.payload, e)
                    return
                try:
                    self._discovered_properties[instance_id]["last_birthdays"] = last_birthdays_prop_obj
                    self._discovered_properties[instance_id]["last_birthdays_version"] = prop_version
                except Exception as e:
                    self._logger.warning("Failed to process property 'last_birthdays' value message: %s", e)
                    return

            self._check_for_fully_discovered(instance_id)
