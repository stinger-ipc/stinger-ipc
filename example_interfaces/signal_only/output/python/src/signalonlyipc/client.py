"""
DO NOT MODIFY THIS FILE.  It is automatically generated by Stinger-IPC 0.6.21 and changes will be over-written
on the next generation.

This is the Client for the SignalOnly interface.

LICENSE: This generated code is not subject to any license restrictions from the generator itself.
TODO: Get license text from stinger file
"""

from typing import Dict, Callable, List, Any, Optional, Union
from uuid import uuid4
from functools import partial, wraps
import json
import logging
from datetime import datetime, timedelta, UTC

from isodate import parse_duration
from stinger_python_utils.message_creator import MessageCreator
from pyqttier.interface import IBrokerConnection
from pyqttier.message import Message
import concurrent.futures as futures
import asyncio
import threading
from stinger_python_utils.return_codes import (
    MethodReturnCode,
    ClientDeserializationErrorStingerMethodException,
    stinger_exception_factory,
)
from .interface_types import *

from pydantic import BaseModel

logging.basicConfig(level=logging.DEBUG)

AnotherSignalSignalCallbackType = Union[Callable[[float, bool, str], None], Callable[[Any, float, bool, str], None]]
BarkSignalCallbackType = Union[Callable[[str], None], Callable[[Any, str], None]]
MaybeNumberSignalCallbackType = Union[Callable[[Optional[int]], None], Callable[[Any, Optional[int]], None]]
MaybeNameSignalCallbackType = Union[Callable[[Optional[str]], None], Callable[[Any, Optional[str]], None]]
NowSignalCallbackType = Union[Callable[[datetime], None], Callable[[Any, datetime], None]]


class DiscoveredInstance(BaseModel):
    instance_id: str


class SignalOnlyClient:

    def __init__(self, connection: IBrokerConnection, instance_info: DiscoveredInstance):
        """Constructor for a `SignalOnlyClient` object."""
        self._logger = logging.getLogger("SignalOnlyClient")
        self._logger.setLevel(logging.DEBUG)
        self._logger.debug("Initializing SignalOnlyClient with %s", instance_info)
        self._conn = connection
        self._conn.add_message_callback(self._receive_message)
        self._service_id = instance_info.instance_id

        self._signal_recv_callbacks_for_another_signal: List[AnotherSignalSignalCallbackType] = []
        self._signal_recv_callbacks_for_bark: List[BarkSignalCallbackType] = []
        self._signal_recv_callbacks_for_maybe_number: List[MaybeNumberSignalCallbackType] = []
        self._signal_recv_callbacks_for_maybe_name: List[MaybeNameSignalCallbackType] = []
        self._signal_recv_callbacks_for_now: List[NowSignalCallbackType] = []

    @property
    def service_id(self) -> str:
        """The service ID of the connected service instance."""
        return self._service_id

    def _do_callbacks_for(self, callbacks: List[Callable[..., None]], **kwargs):
        """Call each callback in the callback dictionary with the provided args."""
        for cb in callbacks:
            cb(**kwargs)

    @staticmethod
    def _filter_for_args(args: Dict[str, Any], allowed_args: List[str]) -> Dict[str, Any]:
        """Given a dictionary, reduce the dictionary so that it only has keys in the allowed list."""
        filtered_args = {}
        for k, v in args.items():
            if k in allowed_args:
                filtered_args[k] = v
        return filtered_args

    def _receive_another_signal_signal_message(self, message: Message):
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'anotherSignal' signal with non-JSON content type")
            return

        model = AnotherSignalSignalPayload.model_validate_json(message.payload)
        kwargs = model.model_dump()

        self._do_callbacks_for(self._signal_recv_callbacks_for_another_signal, **kwargs)

    def _receive_bark_signal_message(self, message: Message):
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'bark' signal with non-JSON content type")
            return

        model = BarkSignalPayload.model_validate_json(message.payload)
        kwargs = model.model_dump()

        self._do_callbacks_for(self._signal_recv_callbacks_for_bark, **kwargs)

    def _receive_maybe_number_signal_message(self, message: Message):
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'maybe_number' signal with non-JSON content type")
            return

        model = MaybeNumberSignalPayload.model_validate_json(message.payload)
        kwargs = model.model_dump()

        self._do_callbacks_for(self._signal_recv_callbacks_for_maybe_number, **kwargs)

    def _receive_maybe_name_signal_message(self, message: Message):
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'maybe_name' signal with non-JSON content type")
            return

        model = MaybeNameSignalPayload.model_validate_json(message.payload)
        kwargs = model.model_dump()

        self._do_callbacks_for(self._signal_recv_callbacks_for_maybe_name, **kwargs)

    def _receive_now_signal_message(self, message: Message):
        if message.content_type is None or message.content_type != "application/json":
            self._logger.warning("Received 'now' signal with non-JSON content type")
            return

        model = NowSignalPayload.model_validate_json(message.payload)
        kwargs = model.model_dump()

        self._do_callbacks_for(self._signal_recv_callbacks_for_now, **kwargs)

    def _receive_any_property_response_message(self, message: Message):
        user_properties = message.user_properties or {}
        return_code = user_properties.get("ReturnCode")
        if return_code is not None and int(return_code) != MethodReturnCode.SUCCESS.value:
            debug_info = user_properties.get("DebugInfo", "")
            self._logger.warning("Received error return value %s from property update: %s", return_code, debug_info)

    def _receive_message(self, message: Message):
        """New MQTT messages are passed to this method, which, based on the topic,
        calls the appropriate handler method for the message.
        """
        self._logger.warning("Receiving message %s, but without a handler", message)

    def receive_another_signal(self, handler: AnotherSignalSignalCallbackType):
        """Used as a decorator for methods which handle particular signals."""
        self._signal_recv_callbacks_for_another_signal.append(handler)
        if len(self._signal_recv_callbacks_for_another_signal) == 1:
            self._conn.subscribe("signalOnly/{}/signal/anotherSignal".format(self._service_id), self._receive_another_signal_signal_message)
        return handler

    def receive_bark(self, handler: BarkSignalCallbackType):
        """Used as a decorator for methods which handle particular signals."""
        self._signal_recv_callbacks_for_bark.append(handler)
        if len(self._signal_recv_callbacks_for_bark) == 1:
            self._conn.subscribe("signalOnly/{}/signal/bark".format(self._service_id), self._receive_bark_signal_message)
        return handler

    def receive_maybe_number(self, handler: MaybeNumberSignalCallbackType):
        """Used as a decorator for methods which handle particular signals."""
        self._signal_recv_callbacks_for_maybe_number.append(handler)
        if len(self._signal_recv_callbacks_for_maybe_number) == 1:
            self._conn.subscribe("signalOnly/{}/signal/maybeNumber".format(self._service_id), self._receive_maybe_number_signal_message)
        return handler

    def receive_maybe_name(self, handler: MaybeNameSignalCallbackType):
        """Used as a decorator for methods which handle particular signals."""
        self._signal_recv_callbacks_for_maybe_name.append(handler)
        if len(self._signal_recv_callbacks_for_maybe_name) == 1:
            self._conn.subscribe("signalOnly/{}/signal/maybeName".format(self._service_id), self._receive_maybe_name_signal_message)
        return handler

    def receive_now(self, handler: NowSignalCallbackType):
        """Used as a decorator for methods which handle particular signals."""
        self._signal_recv_callbacks_for_now.append(handler)
        if len(self._signal_recv_callbacks_for_now) == 1:
            self._conn.subscribe("signalOnly/{}/signal/now".format(self._service_id), self._receive_now_signal_message)
        return handler


class SignalOnlyClientBuilder:
    """Using decorators from SignalOnlyClient doesn't work if you are trying to create multiple instances of SignalOnlyClient.
    Instead, use this builder to create a registry of callbacks, and then build clients using the registry.

    When ready to create a SignalOnlyClient instance, call the `build(broker, service_instance_id)` method.
    """

    def __init__(self):
        """Creates a new SignalOnlyClientBuilder."""
        self._logger = logging.getLogger("SignalOnlyClientBuilder")
        self._signal_recv_callbacks_for_another_signal = []  # type: List[AnotherSignalSignalCallbackType]
        self._signal_recv_callbacks_for_bark = []  # type: List[BarkSignalCallbackType]
        self._signal_recv_callbacks_for_maybe_number = []  # type: List[MaybeNumberSignalCallbackType]
        self._signal_recv_callbacks_for_maybe_name = []  # type: List[MaybeNameSignalCallbackType]
        self._signal_recv_callbacks_for_now = []  # type: List[NowSignalCallbackType]

    def receive_another_signal(self, handler):
        """Used as a decorator for methods which handle particular signals."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._signal_recv_callbacks_for_another_signal.append(wrapper)
        return wrapper

    def receive_bark(self, handler):
        """Used as a decorator for methods which handle particular signals."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._signal_recv_callbacks_for_bark.append(wrapper)
        return wrapper

    def receive_maybe_number(self, handler):
        """Used as a decorator for methods which handle particular signals."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._signal_recv_callbacks_for_maybe_number.append(wrapper)
        return wrapper

    def receive_maybe_name(self, handler):
        """Used as a decorator for methods which handle particular signals."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._signal_recv_callbacks_for_maybe_name.append(wrapper)
        return wrapper

    def receive_now(self, handler):
        """Used as a decorator for methods which handle particular signals."""

        @wraps(handler)
        def wrapper(*args, **kwargs):
            return handler(*args, **kwargs)

        self._signal_recv_callbacks_for_now.append(wrapper)
        return wrapper

    def build(self, broker: IBrokerConnection, instance_info: DiscoveredInstance, binding: Optional[Any] = None) -> SignalOnlyClient:
        """Builds a new SignalOnlyClient."""
        self._logger.debug("Building SignalOnlyClient for service instance %s", instance_info.instance_id)
        client = SignalOnlyClient(broker, instance_info)

        for another_signal_cb in self._signal_recv_callbacks_for_another_signal:
            if binding:
                client.receive_another_signal(another_signal_cb.__get__(binding, binding.__class__))
            else:
                client.receive_another_signal(another_signal_cb)

        for bark_cb in self._signal_recv_callbacks_for_bark:
            if binding:
                client.receive_bark(bark_cb.__get__(binding, binding.__class__))
            else:
                client.receive_bark(bark_cb)

        for maybe_number_cb in self._signal_recv_callbacks_for_maybe_number:
            if binding:
                client.receive_maybe_number(maybe_number_cb.__get__(binding, binding.__class__))
            else:
                client.receive_maybe_number(maybe_number_cb)

        for maybe_name_cb in self._signal_recv_callbacks_for_maybe_name:
            if binding:
                client.receive_maybe_name(maybe_name_cb.__get__(binding, binding.__class__))
            else:
                client.receive_maybe_name(maybe_name_cb)

        for now_cb in self._signal_recv_callbacks_for_now:
            if binding:
                client.receive_now(now_cb.__get__(binding, binding.__class__))
            else:
                client.receive_now(now_cb)

        return client


class SignalOnlyClientDiscoverer:

    def __init__(self, connection: IBrokerConnection, builder: Optional[SignalOnlyClientBuilder] = None, build_binding: Optional[Any] = None):
        """Creates a new SignalOnlyClientDiscoverer."""
        self._conn = connection
        self._builder = builder
        self._build_binding = build_binding
        self._logger = logging.getLogger("SignalOnlyClientDiscoverer")
        self._logger.setLevel(logging.DEBUG)
        service_discovery_topic = "signalOnly/{}/interface".format("+")
        self._conn.subscribe(service_discovery_topic, self._process_service_discovery_message)
        self._mutex = threading.Lock()
        self._pending_futures: List[futures.Future] = []
        self._removed_service_callbacks: List[Callable[[str], None]] = []

        # For partially discovered services
        self._discovered_interface_infos = dict()  # type: Dict[str, InterfaceInfo]

        # For fully discovered services
        self._discovered_services: Dict[str, DiscoveredInstance] = {}
        self._discovered_service_callbacks: List[Callable[[DiscoveredInstance], None]] = []

    def add_discovered_service_callback(self, callback: Callable[[DiscoveredInstance], None]):
        """Adds a callback to be called when a new service is discovered."""
        with self._mutex:
            for instance in self._discovered_services.values():
                callback(instance)
            self._discovered_service_callbacks.append(callback)

    def add_removed_service_callback(self, callback: Callable[[str], None]):
        """Adds a callback to be called when a service is removed."""
        with self._mutex:
            self._removed_service_callbacks.append(callback)

    def get_service_instance_ids(self) -> List[str]:
        """Returns a list of currently discovered service instance IDs."""
        with self._mutex:
            return list(self._discovered_services.keys())

    def get_discovery_info(self, instance_id: str) -> Optional[DiscoveredInstance]:
        """Returns the DiscoveredInstance for a discovered service instance ID, or None if not found."""
        with self._mutex:
            return self._discovered_services.get(instance_id, None)

    def get_singleton_client(self) -> futures.Future[SignalOnlyClient]:
        """Returns a SignalOnlyClient for the single discovered service.
        Raises an exception if there is not exactly one discovered service.
        """
        fut = futures.Future()  # type: futures.Future[SignalOnlyClient]
        with self._mutex:
            if len(self._discovered_services) > 0:
                instance_info = next(iter(self._discovered_services.values()))
                if self._builder is None:
                    fut.set_result(SignalOnlyClient(self._conn, instance_info))
                else:
                    new_client = self._builder.build(self._conn, instance_info, self._build_binding)
                    fut.set_result(new_client)
            else:
                self._pending_futures.append(fut)
        return fut

    def _check_for_fully_discovered(self, instance_id: str):
        """Checks if interface info has been discovered for the given instance ID."""
        with self._mutex:
            if instance_id in self._discovered_interface_infos:

                entry = DiscoveredInstance(
                    instance_id=instance_id,
                )
                is_new_entry = not instance_id in self._discovered_services

                self._discovered_services[instance_id] = entry
                while self._pending_futures:
                    self._logger.info("Creating a client object id=%s and returning as future result", instance_id)
                    fut = self._pending_futures.pop(0)
                    if not fut.done():
                        if self._builder is not None:
                            fut.set_result(self._builder.build(self._conn, entry, self._build_binding))
                        else:
                            fut.set_result(SignalOnlyClient(self._conn, entry))
                if is_new_entry:
                    self._logger.info("Discovered service: %s", instance_id)
                    for cb in self._discovered_service_callbacks:
                        cb(entry)
                else:
                    self._logger.debug("Updated info for service: %s", instance_id)

    def _process_service_discovery_message(self, message: Message):
        """Processes a service discovery message."""
        self._logger.debug("Processing service discovery message on topic %s", message.topic)
        if len(message.payload) > 0:
            try:
                service_info = InterfaceInfo.model_validate_json(message.payload)
                with self._mutex:
                    self._discovered_interface_infos[service_info.instance] = service_info
            except Exception as e:
                self._logger.warning("Failed to process service discovery message: %s", e)
            self._check_for_fully_discovered(service_info.instance)

        else:  # Empty payload means the service is going away
            instance_id = message.topic.split("/")[-2]
            with self._mutex:
                if instance_id in self._discovered_services:
                    self._logger.info("Service %s is going away", instance_id)
                    if instance_id in self._discovered_services:
                        del self._discovered_services[instance_id]
                    if instance_id in self._discovered_interface_infos:
                        del self._discovered_interface_infos[instance_id]
                    for cb in self._removed_service_callbacks:
                        cb(instance_id)
