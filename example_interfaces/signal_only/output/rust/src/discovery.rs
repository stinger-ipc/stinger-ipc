/*
DO NOT MODIFY THIS FILE.  It is automatically generated by Stinger-IPC 0.6.11 and changes will be over-written
on the next generation.

This is the Client for the SignalOnly interface.

LICENSE: This generated code is not subject to any license restrictions from the generator itself.
TODO: Get license text from stinger file
*/
use std::collections::HashMap;
use std::fmt;
use std::sync::{Arc, RwLock};

use crate::interface::InterfaceInfo;
use stinger_mqtt_trait::message::{MqttMessage, QoS};
use stinger_mqtt_trait::{Mqtt5PubSub, Mqtt5PubSubError};
use tokio::sync::broadcast;
use tokio::task::JoinHandle;
#[allow(unused_imports)]
use tracing::{debug, error, info, warn};

#[allow(unused_imports)]
use crate::payloads::*;
#[cfg(feature = "metrics")]
use std::sync::Mutex;

#[derive(Debug)]
pub enum SignalOnlyDiscoveryError {
    Subscribe(Mqtt5PubSubError),
}

impl fmt::Display for SignalOnlyDiscoveryError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SignalOnlyDiscoveryError::Subscribe(err) => {
                write!(f, "failed to subscribe for discovery: {err}")
            }
        }
    }
}

impl std::error::Error for SignalOnlyDiscoveryError {}

impl From<Mqtt5PubSubError> for SignalOnlyDiscoveryError {
    fn from(value: Mqtt5PubSubError) -> Self {
        SignalOnlyDiscoveryError::Subscribe(value)
    }
}

struct ServiceInDiscovery {
    pub interface_info: Option<InterfaceInfo>,

    pub fully_discovered: std::sync::atomic::AtomicBool,
}

impl Default for ServiceInDiscovery {
    fn default() -> Self {
        Self {
            interface_info: None,

            fully_discovered: std::sync::atomic::AtomicBool::new(false),
        }
    }
}

#[derive(Clone, Debug)]
pub struct DiscoveredService {
    pub interface_info: InterfaceInfo,
}

impl ServiceInDiscovery {
    /// Attempts to convert a ServiceInDiscovery into a DiscoveredService
    pub fn to_discovered_service(&self) -> Option<DiscoveredService> {
        match &self.interface_info {
            Some(info) => Some(DiscoveredService {
                interface_info: info.clone(),
            }),
            _ => None,
        }
    }
}

#[cfg(feature = "metrics")]
#[derive(Debug)]
pub struct SignalOnlyDiscoveryMetrics {
    pub discovery_start_time: std::time::Instant,
    pub time_of_first_discovery: Option<std::time::Instant>,
    pub received_property_values: std::sync::atomic::AtomicU32,
}

#[cfg(feature = "metrics")]
impl Default for SignalOnlyDiscoveryMetrics {
    fn default() -> Self {
        Self {
            discovery_start_time: std::time::Instant::now(),
            time_of_first_discovery: None,
            received_property_values: std::sync::atomic::AtomicU32::new(0),
        }
    }
}

#[cfg(feature = "metrics")]
impl SignalOnlyDiscoveryMetrics {
    /// Sets the time_of_first_discovery if it hasn't been set yet
    pub fn set_time_of_first_discovery(&mut self) {
        if self.time_of_first_discovery.is_none() {
            self.time_of_first_discovery = Some(std::time::Instant::now());
        }
    }

    /// Returns the time in milliseconds between `discovery_start_time` and
    /// `time_of_first_discovery`, or `None` if `time_of_first_discovery` is not set.
    pub fn time_to_first_discovery_ms(&self) -> Option<u128> {
        self.time_of_first_discovery
            .as_ref()
            .map(|t| t.duration_since(self.discovery_start_time).as_millis())
    }
}

pub struct SignalOnlyDiscovery<C: Mqtt5PubSub + Clone + Send + Sync + 'static> {
    connection: C,
    service_name: String,
    instances_in_discovery: Arc<RwLock<HashMap<String, ServiceInDiscovery>>>,
    info_listener_handle: JoinHandle<()>,

    notification_tx: broadcast::Sender<DiscoveredService>,
    #[cfg(feature = "metrics")]
    pub metrics: Arc<Mutex<SignalOnlyDiscoveryMetrics>>,
}

/// Event receiver for new interface discovery notifications
pub type SignalOnlyDiscoveryReceiver = broadcast::Receiver<DiscoveredService>;

impl<C: Mqtt5PubSub + Clone + Send + Sync + 'static> SignalOnlyDiscovery<C> {
    pub async fn new(connection: &mut C) -> Result<Self, SignalOnlyDiscoveryError> {
        let service_name = "SignalOnly".to_string();
        let discovery_topic = format!("signalOnly/{}/interface", "+");

        let (info_tx, info_rx) = broadcast::channel::<MqttMessage>(32);
        debug!("Subscribing to discovery topic: {discovery_topic}");
        let _subscription_id = connection
            .subscribe(discovery_topic, QoS::AtLeastOnce, info_tx.clone())
            .await
            .map_err(SignalOnlyDiscoveryError::from)?;

        let instances_in_discovery = Arc::new(RwLock::new(HashMap::new()));

        // Clients can get a notification receiver by calling the subscribe() method.
        let (notification_tx, _notification_rx) = broadcast::channel::<DiscoveredService>(32);

        #[cfg(feature = "metrics")]
        let metrics = Arc::new(Mutex::new(SignalOnlyDiscoveryMetrics::default()));

        let info_listener_handle = Self::spawn_listener(
            info_rx,
            instances_in_discovery.clone(),
            notification_tx.clone(),
            #[cfg(feature = "metrics")]
            metrics.clone(),
        );

        Ok(Self {
            connection: connection.clone(),
            service_name,
            instances_in_discovery,
            info_listener_handle,

            notification_tx,
            #[cfg(feature = "metrics")]
            metrics,
        })
    }

    pub fn service_name(&self) -> &str {
        &self.service_name
    }

    pub fn instances_in_discovery(&self) -> Vec<DiscoveredService> {
        let guard = self
            .instances_in_discovery
            .read()
            .expect("interfaces poisoned");
        guard
            .values()
            .filter(|sd| {
                sd.fully_discovered
                    .load(std::sync::atomic::Ordering::Relaxed)
            })
            .filter_map(|sd| sd.to_discovered_service())
            .collect()
    }

    pub async fn get_singleton_service(&self) -> DiscoveredService {
        // First check if we already have an interface
        {
            let instance_map = self
                .instances_in_discovery
                .read()
                .expect("interfaces poisoned");
            if let Some(entry) = instance_map.values().next() {
                if entry.interface_info.is_some() {
                    {
                        return DiscoveredService {
                            interface_info: entry.interface_info.clone().unwrap(),
                        };
                    }
                }
            }
        }

        // No interfaces yet, wait for the first one to be discovered
        let mut receiver = self.notification_tx.subscribe();
        receiver.recv().await.expect("notification channel closed")
    }

    pub fn subscribe(&self) -> SignalOnlyDiscoveryReceiver {
        self.notification_tx.subscribe()
    }

    fn try_publish_discovered_service(
        service_in_discovery: &ServiceInDiscovery,
        notification_tx: &broadcast::Sender<DiscoveredService>,
        #[cfg(feature = "metrics")] metrics: &Arc<Mutex<SignalOnlyDiscoveryMetrics>>,
    ) {
        // Check if this completes the discovery

        if let Some(discovered) = service_in_discovery.to_discovered_service() {
            service_in_discovery
                .fully_discovered
                .store(true, std::sync::atomic::Ordering::Relaxed);
            let _ = notification_tx.send(discovered);
            #[cfg(feature = "metrics")]
            {
                let mut metrics_guard = metrics.lock().unwrap();
                metrics_guard.set_time_of_first_discovery();
            }
        }
    }

    fn spawn_listener(
        mut message_rx: broadcast::Receiver<MqttMessage>,
        instances_in_discovery: Arc<RwLock<HashMap<String, ServiceInDiscovery>>>,
        notification_tx: broadcast::Sender<DiscoveredService>,
        #[cfg(feature = "metrics")] metrics: Arc<Mutex<SignalOnlyDiscoveryMetrics>>,
    ) -> JoinHandle<()> {
        tokio::spawn(async move {
            debug!("Listening for discovery messages");
            while let Ok(message) = message_rx.recv().await {
                Self::handle_message(
                    message,
                    &instances_in_discovery,
                    &notification_tx,
                    #[cfg(feature = "metrics")]
                    metrics.clone(),
                );
            }
        })
    }

    fn handle_message(
        message: MqttMessage,
        instances_in_discovery: &Arc<RwLock<HashMap<String, ServiceInDiscovery>>>,
        notification_tx: &broadcast::Sender<DiscoveredService>,
        #[cfg(feature = "metrics")] metrics: Arc<Mutex<SignalOnlyDiscoveryMetrics>>,
    ) {
        if message.payload.is_empty() {
            info!("Service represented by {} is now offline", message.topic);
            // Parse instance_id from topic (format: full/{instance_id}/interface)
            let topic_parts: Vec<&str> = message.topic.split('/').collect();
            if topic_parts.len() >= 2 {
                let instance_id = topic_parts[topic_parts.len() - 2].to_string();
                let mut interfaces_guard = instances_in_discovery
                    .write()
                    .expect("interfaces write lock poisoned");
                interfaces_guard.remove(&instance_id);
                drop(interfaces_guard);
            }
        } else {
            let deserialized = serde_json::from_slice::<InterfaceInfo>(&message.payload);
            match deserialized {
                Ok(info) => {
                    info!("Discovered service instance: {:?}", info);
                    {
                        let mut instance_map = instances_in_discovery
                            .write()
                            .expect("interfaces write lock poisoned");
                        let service_in_discovery =
                            instance_map.entry(info.instance.clone()).or_default();
                        service_in_discovery.interface_info = Some(info);
                        Self::try_publish_discovered_service(
                            service_in_discovery,
                            notification_tx,
                            #[cfg(feature = "metrics")]
                            &metrics,
                        );
                    }
                }
                Err(err) => {
                    error!(
                        "Failed to deserialize InterfaceInfo from {}: {}",
                        message.topic, err
                    );
                }
            }
        }
    }
}

impl<C: Mqtt5PubSub + Clone + Send + Sync + 'static> Drop for SignalOnlyDiscovery<C> {
    fn drop(&mut self) {
        self.info_listener_handle.abort();
        let _ = self
            .connection
            .unsubscribe(format!("signalOnly/{}/interface", "+"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_message(topic: &str, instance: &str) -> MqttMessage {
        let info = InterfaceInfo {
            interface_name: "sample".into(),
            title: "Sample".into(),
            version: "1.0".into(),
            instance: instance.into(),
            connection_topic: format!("sample/{instance}"),
            timestamp: "2024-01-01T00:00:00Z".into(),
        };
        let payload = serde_json::to_vec(&info).expect("serialize");

        MqttMessage {
            topic: topic.into(),
            payload,
            qos: 1,
            subscription_id: 42,
            response_topic: None,
            content_type: None,
            correlation_data: None,
            user_properties: HashMap::new(),
        }
    }

    #[tokio::test]
    async fn collects_unique_instances_and_topics() {
        let interfaces = Arc::new(RwLock::new(HashMap::new()));
        let (notification_tx, mut notification_rx) = broadcast::channel::<InterfaceInfo>(32);

        SignalOnlyDiscovery::handle_message(
            sample_message("service/alpha/interface", "alpha"),
            &interfaces,
            &notification_tx,
        );
        SignalOnlyDiscovery::handle_message(
            sample_message("service/beta/interface", "beta"),
            &interfaces,
            &notification_tx,
        );
        SignalOnlyDiscovery::handle_message(
            sample_message("service/alpha/interface", "alpha"),
            &interfaces,
            &notification_tx,
        );

        let interfaces_guard = interfaces.read().unwrap();
        assert_eq!(interfaces_guard.len(), 2);
        assert!(interfaces_guard.contains_key("alpha"));
        assert!(interfaces_guard.contains_key("beta"));

        // Check that we received exactly 2 notifications (only for new interfaces)
        let info1 = notification_rx
            .try_recv()
            .expect("should have first notification");
        assert_eq!(info1.instance, "alpha");
        let info2 = notification_rx
            .try_recv()
            .expect("should have second notification");
        assert_eq!(info2.instance, "beta");
        assert!(
            notification_rx.try_recv().is_err(),
            "should not have third notification"
        );
    }
}
