//! Client module for SignalOnly IPC
//!
//! This module is only available when the "client" feature is enabled.

/*
DO NOT MODIFY THIS FILE.  It is automatically generated by Stinger-IPC 0.6.21 and changes will be over-written
on the next generation.

This is the Client for the SignalOnly interface.

LICENSE: This generated code is not subject to any license restrictions from the generator itself.
TODO: Get license text from stinger file
*/
use crate::discovery::DiscoveredService;
use crate::message;
#[allow(unused_imports)]
use crate::payloads::{MethodReturnCode, *};
#[allow(unused_imports)]
use iso8601_duration::Duration as IsoDuration;
use serde_json;
use std::sync::{Arc, Mutex};
use stinger_mqtt_trait::message::{MqttMessage, QoS};
#[cfg(feature = "client")]
use stinger_mqtt_trait::Mqtt5PubSub;
use tokio::sync::broadcast;
use tokio::task::JoinError;
#[allow(unused_imports)]
use tracing::{debug, error, info, warn};

/// This struct is used to store all the MQTTv5 subscription ids
/// for the subscriptions the client will make.
#[derive(Clone, Debug)]
struct SignalOnlySubscriptionIds {
    another_signal_signal: Option<u32>,
    bark_signal: Option<u32>,
    maybe_number_signal: Option<u32>,
    maybe_name_signal: Option<u32>,
    now_signal: Option<u32>,
}

/// This struct holds the tx side of a broadcast channels used when receiving signals.
/// The rx side of the broadcast channels can be created from the tx side later.
/// When SignalOnlyClient gets a message and determines that it
/// is a signal, it will send the signal payload via the tx channel that is in this struct.
#[derive(Clone)]
struct SignalOnlySignalChannels {
    another_signal_sender: broadcast::Sender<AnotherSignalSignalPayload>,
    bark_sender: broadcast::Sender<String>,
    maybe_number_sender: broadcast::Sender<Option<i32>>,
    maybe_name_sender: broadcast::Sender<Option<String>>,
    now_sender: broadcast::Sender<chrono::DateTime<chrono::Utc>>,
}

/// This is the struct for our API client.
#[derive(Clone)]
pub struct SignalOnlyClient<C: Mqtt5PubSub> {
    mqtt_client: C,

    /// Temporarily holds the receiver for the broadcast channel.  The Receiver will be moved
    /// to a process loop when it is needed.  MQTT messages will be received with this.
    msg_streamer_rx: Arc<Mutex<Option<broadcast::Receiver<MqttMessage>>>>,

    /// The Sender side of MQTT messages that are received from the broker.  This tx
    /// side is cloned for each subscription made.
    #[allow(dead_code)]
    msg_streamer_tx: broadcast::Sender<MqttMessage>,

    /// Contains all the MQTTv5 subscription ids.
    subscription_ids: SignalOnlySubscriptionIds,
    /// Holds the channels used for sending signals to the application.
    signal_channels: SignalOnlySignalChannels,

    /// Copy of MQTT Client ID
    pub client_id: String,
}

impl<C: Mqtt5PubSub + Clone + Send + 'static> SignalOnlyClient<C> {
    /// Creates a new SignalOnlyClient that uses an Mqtt5PubSub.
    pub async fn new(mut connection: C, discovery_info: DiscoveredService) -> Self {
        // Create a channel for messages to get from the Connection object to this SignalOnlyClient object.
        // The Connection object uses a clone of the tx side of the channel.
        let (message_received_tx, message_received_rx) = broadcast::channel(64);

        let client_id = connection.get_client_id();

        // Subscribe to all the topics needed for signals.
        let topic_another_signal_signal = format!(
            "signalOnly/{}/signal/anotherSignal",
            discovery_info.interface_info.instance
        );
        let subscription_id_another_signal_signal = connection
            .subscribe(
                topic_another_signal_signal,
                QoS::ExactlyOnce,
                message_received_tx.clone(),
            )
            .await;
        let subscription_id_another_signal_signal =
            subscription_id_another_signal_signal.unwrap_or(u32::MAX);
        debug!(
            "Subscription (id={}) to signal topic for 'anotherSignal'",
            subscription_id_another_signal_signal
        );
        let topic_bark_signal = format!(
            "signalOnly/{}/signal/bark",
            discovery_info.interface_info.instance
        );
        let subscription_id_bark_signal = connection
            .subscribe(
                topic_bark_signal,
                QoS::ExactlyOnce,
                message_received_tx.clone(),
            )
            .await;
        let subscription_id_bark_signal = subscription_id_bark_signal.unwrap_or(u32::MAX);
        debug!(
            "Subscription (id={}) to signal topic for 'bark'",
            subscription_id_bark_signal
        );
        let topic_maybe_number_signal = format!(
            "signalOnly/{}/signal/maybeNumber",
            discovery_info.interface_info.instance
        );
        let subscription_id_maybe_number_signal = connection
            .subscribe(
                topic_maybe_number_signal,
                QoS::ExactlyOnce,
                message_received_tx.clone(),
            )
            .await;
        let subscription_id_maybe_number_signal =
            subscription_id_maybe_number_signal.unwrap_or(u32::MAX);
        debug!(
            "Subscription (id={}) to signal topic for 'maybe_number'",
            subscription_id_maybe_number_signal
        );
        let topic_maybe_name_signal = format!(
            "signalOnly/{}/signal/maybeName",
            discovery_info.interface_info.instance
        );
        let subscription_id_maybe_name_signal = connection
            .subscribe(
                topic_maybe_name_signal,
                QoS::ExactlyOnce,
                message_received_tx.clone(),
            )
            .await;
        let subscription_id_maybe_name_signal =
            subscription_id_maybe_name_signal.unwrap_or(u32::MAX);
        debug!(
            "Subscription (id={}) to signal topic for 'maybe_name'",
            subscription_id_maybe_name_signal
        );
        let topic_now_signal = format!(
            "signalOnly/{}/signal/now",
            discovery_info.interface_info.instance
        );
        let subscription_id_now_signal = connection
            .subscribe(
                topic_now_signal,
                QoS::ExactlyOnce,
                message_received_tx.clone(),
            )
            .await;
        let subscription_id_now_signal = subscription_id_now_signal.unwrap_or(u32::MAX);
        debug!(
            "Subscription (id={}) to signal topic for 'now'",
            subscription_id_now_signal
        );

        // Subscribe to all the topics needed for properties.

        // Create structure for subscription ids.
        let sub_ids = SignalOnlySubscriptionIds {
            another_signal_signal: Some(subscription_id_another_signal_signal),
            bark_signal: Some(subscription_id_bark_signal),
            maybe_number_signal: Some(subscription_id_maybe_number_signal),
            maybe_name_signal: Some(subscription_id_maybe_name_signal),
            now_signal: Some(subscription_id_now_signal),
        };

        // Create structure for the tx side of broadcast channels for signals.
        let signal_channels = SignalOnlySignalChannels {
            another_signal_sender: broadcast::channel(64).0,
            bark_sender: broadcast::channel(64).0,
            maybe_number_sender: broadcast::channel(64).0,
            maybe_name_sender: broadcast::channel(64).0,
            now_sender: broadcast::channel(64).0,
        };

        // Create SignalOnlyClient structure.
        SignalOnlyClient {
            mqtt_client: connection,

            msg_streamer_rx: Arc::new(Mutex::new(Some(message_received_rx))),
            msg_streamer_tx: message_received_tx,

            subscription_ids: sub_ids,
            signal_channels,
            client_id,
        }
    }

    /// Get the RX receiver side of the broadcast channel for the anotherSignal signal.
    /// The signal payload, `AnotherSignalSignalPayload`, will be put onto the channel whenever it is received.
    pub fn get_another_signal_receiver(&self) -> broadcast::Receiver<AnotherSignalSignalPayload> {
        self.signal_channels.another_signal_sender.subscribe()
    }
    /// Get the RX receiver side of the broadcast channel for the bark signal.
    /// The signal payload, `BarkSignalPayload`, will be put onto the channel whenever it is received.
    pub fn get_bark_receiver(&self) -> broadcast::Receiver<String> {
        self.signal_channels.bark_sender.subscribe()
    }
    /// Get the RX receiver side of the broadcast channel for the maybe_number signal.
    /// The signal payload, `MaybeNumberSignalPayload`, will be put onto the channel whenever it is received.
    pub fn get_maybe_number_receiver(&self) -> broadcast::Receiver<Option<i32>> {
        self.signal_channels.maybe_number_sender.subscribe()
    }
    /// Get the RX receiver side of the broadcast channel for the maybe_name signal.
    /// The signal payload, `MaybeNameSignalPayload`, will be put onto the channel whenever it is received.
    pub fn get_maybe_name_receiver(&self) -> broadcast::Receiver<Option<String>> {
        self.signal_channels.maybe_name_sender.subscribe()
    }
    /// Get the RX receiver side of the broadcast channel for the now signal.
    /// The signal payload, `NowSignalPayload`, will be put onto the channel whenever it is received.
    pub fn get_now_receiver(&self) -> broadcast::Receiver<chrono::DateTime<chrono::Utc>> {
        self.signal_channels.now_sender.subscribe()
    }

    fn get_return_code_from_message(msg: &MqttMessage) -> MethodReturnCode {
        let payload = String::from_utf8_lossy(&msg.payload).to_string();
        let mut return_code: MethodReturnCode = MethodReturnCode::Success(Some(payload));
        if let Some(retval) = msg.user_properties.get("ReturnCode") {
            let opt_dbg_info = msg.user_properties.get("DebugInfo").cloned();
            if let Ok(return_code_u32) = retval.parse::<u32>() {
                if return_code_u32 != 0 {
                    return_code = MethodReturnCode::from_code(return_code_u32, opt_dbg_info);
                } else {
                    info!("Received Debug Info: {:?}", opt_dbg_info);
                }
            }
        }
        return_code
    }

    /// Starts the tasks that process messages received.
    pub async fn run_loop(&mut self) -> Result<(), JoinError> {
        // Take ownership of the RX channel that receives MQTT messages.  This will be moved into the loop_task.
        let mut message_receiver = {
            let mut guard = self.msg_streamer_rx.lock().expect("Mutex was poisoned");
            guard.take().expect("msg_streamer_rx should be Some")
        };

        let sig_chans = self.signal_channels.clone();

        let sub_ids = self.subscription_ids.clone();
        let _loop_task = tokio::spawn(async move {
            while let Ok(msg) = message_receiver.recv().await {
                if let Some(subscription_id) = msg.subscription_id {
                    match subscription_id {
                        _i if sub_ids.another_signal_signal == Some(_i) => {
                            debug!("Received anotherSignal signal message");
                            // Find broadcast channel.
                            let chan = sig_chans.another_signal_sender.clone();

                            // 3 arguments, send the entire struct to the channel.
                            match serde_json::from_slice::<AnotherSignalSignalPayload>(&msg.payload)
                            {
                                Ok(pl) => {
                                    let _send_result = chan.send(pl);
                                }
                                Err(e) => {
                                    warn!("Failed to deserialize '{}' into AnotherSignalSignalPayload: {}", String::from_utf8_lossy(&msg.payload), e);
                                    continue;
                                }
                            }
                        }

                        _i if sub_ids.bark_signal == Some(_i) => {
                            debug!("Received bark signal message");
                            // Find broadcast channel.
                            let chan = sig_chans.bark_sender.clone();

                            // Single argument, extract it from payload and send to channel.
                            match serde_json::from_slice::<BarkSignalPayload>(&msg.payload) {
                                Ok(pl) => {
                                    let _send_result = chan.send(pl.word);
                                }
                                Err(e) => {
                                    warn!(
                                        "Failed to deserialize '{}' into BarkSignalPayload: {}",
                                        String::from_utf8_lossy(&msg.payload),
                                        e
                                    );
                                    continue;
                                }
                            }
                        }

                        _i if sub_ids.maybe_number_signal == Some(_i) => {
                            debug!("Received maybe_number signal message");
                            // Find broadcast channel.
                            let chan = sig_chans.maybe_number_sender.clone();

                            // Single argument, extract it from payload and send to channel.
                            match serde_json::from_slice::<MaybeNumberSignalPayload>(&msg.payload) {
                                Ok(pl) => {
                                    let _send_result = chan.send(pl.number);
                                }
                                Err(e) => {
                                    warn!("Failed to deserialize '{}' into MaybeNumberSignalPayload: {}", String::from_utf8_lossy(&msg.payload), e);
                                    continue;
                                }
                            }
                        }

                        _i if sub_ids.maybe_name_signal == Some(_i) => {
                            debug!("Received maybe_name signal message");
                            // Find broadcast channel.
                            let chan = sig_chans.maybe_name_sender.clone();

                            // Single argument, extract it from payload and send to channel.
                            match serde_json::from_slice::<MaybeNameSignalPayload>(&msg.payload) {
                                Ok(pl) => {
                                    let _send_result = chan.send(pl.name);
                                }
                                Err(e) => {
                                    warn!("Failed to deserialize '{}' into MaybeNameSignalPayload: {}", String::from_utf8_lossy(&msg.payload), e);
                                    continue;
                                }
                            }
                        }

                        _i if sub_ids.now_signal == Some(_i) => {
                            debug!("Received now signal message");
                            // Find broadcast channel.
                            let chan = sig_chans.now_sender.clone();

                            // Single argument, extract it from payload and send to channel.
                            match serde_json::from_slice::<NowSignalPayload>(&msg.payload) {
                                Ok(pl) => {
                                    let _send_result = chan.send(pl.timestamp);
                                }
                                Err(e) => {
                                    warn!(
                                        "Failed to deserialize '{}' into NowSignalPayload: {}",
                                        String::from_utf8_lossy(&msg.payload),
                                        e
                                    );
                                    continue;
                                }
                            }
                        }

                        unhandled_subscription_id => {
                            error!(
                                "Received message with unmatched subscription id: {}",
                                unhandled_subscription_id
                            );
                        }
                    }
                } else {
                    error!("Received message without a subscription id");
                }
            }
        });

        Ok(())
    }
}
