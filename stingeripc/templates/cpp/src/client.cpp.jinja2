{% import "partials/deserialize.jinja2" as deser %}
{% import "partials/serialize.jinja2" as ser %}
{% import "partials/args.jinja2" as ar %}
{% import "partials/properties.jinja2" as pr %}

#include <vector>
#include <iostream>
#include <chrono>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <syslog.h>
#include <sstream>
#include <stinger/utils/iconnection.hpp>
#include <stinger/utils/uuid.hpp>
#include <stinger/utils/format.hpp>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>
#include <rapidjson/error/en.h>
#include <rapidjson/document.h>
#include "structs.hpp"
#include "client.hpp"
#include "{{stinger.cpp.enum_header_file}}"
#include "discovery.hpp"

{%for ns in config.cpp.namespace%}
namespace {{ns}} {
{%endfor-%}
namespace {{stinger.name|snake_case}} {

constexpr const char {{stinger.cpp.client_class_name}}::NAME[];
constexpr const char {{stinger.cpp.client_class_name}}::INTERFACE_VERSION[];

{{stinger.cpp.client_class_name}}::{{stinger.cpp.client_class_name}}(std::shared_ptr<stinger::utils::IConnection> broker, const InstanceInfo& instanceInfo)
        : _broker(broker), _instanceId(instanceInfo.serviceId.value_or("error_service_id_not_found")), _instanceInfo(instanceInfo)
{
    _brokerMessageCallbackHandle = _broker->AddMessageCallback([this](const stinger::utils::MqttMessage& msg)
    {
        _receiveMessage(msg);
    });

    std::map<std::string, std::string> topicArgs;
    topicArgs["service_id"] = _instanceInfo.serviceId.value_or("error_service_id_not_found");
    topicArgs["interface_name"] = NAME;
    {%-for topic_param in config.topics.params %}
    topicArgs["{{topic_param}}"] = _instanceInfo.{{topic_param|lowerCamelCase}}.value_or("error_{{topic_param}}_not_found");
    {%-endfor%}

    {%for sig_name, sig in stinger.signals.items() %}
    auto {{sig_name | lowerCamelCase}}Topic = stinger::utils::format("{{sig.topic()}}", topicArgs);
    _{{sig_name | lowerCamelCase}}SignalSubscriptionId = _broker->Subscribe({{sig_name | lowerCamelCase}}Topic, 2);
    {%-endfor%}
    {%-for method_name, method in stinger.methods.items() %}
    { // Restrict scope
        auto {{method_name | lowerCamelCase}}RequestTopic = stinger::utils::format("{{method.request_topic()}}", topicArgs);
        std::stringstream responseTopicStringStream;
        responseTopicStringStream << stinger::utils::format({{method_name|lowerCamelCase}}RequestTopic, topicArgs);
        _{{method_name | lowerCamelCase}}MethodSubscriptionId = _broker->Subscribe(responseTopicStringStream.str(), 2);
    }
    {%-endfor%}

    {%-for prop_name, prop in stinger.properties.items() %}
    auto {{prop_name | lowerCamelCase}}ValueTopic = stinger::utils::format("{{prop.value_topic()}}", topicArgs);
    _{{prop_name | lowerCamelCase}}PropertySubscriptionId = _broker->Subscribe({{prop_name | lowerCamelCase}}ValueTopic, 1);
    {%-endfor%}
}

{{stinger.cpp.client_class_name}}::~{{stinger.cpp.client_class_name}}()
{
    if (_broker && _brokerMessageCallbackHandle != 0)
    {
        _broker->RemoveMessageCallback(_brokerMessageCallbackHandle);
        _brokerMessageCallbackHandle = 0;
    }
}

void {{stinger.cpp.client_class_name}}::_receiveMessage(const stinger::utils::MqttMessage& msg)
{
    const int noSubId = -1;
    int subscriptionId = msg.mqttProps.subscriptionId.value_or(noSubId);
    _broker->Log(LOG_DEBUG, "Received message on topic %s with subscription id=%d", msg.topic.c_str(), subscriptionId);
    {%-for sig_name, sig in stinger.signals.items() %}
    if (subscriptionId == _{{sig_name | lowerCamelCase}}SignalSubscriptionId)
    {
        _broker->Log(LOG_INFO, "Handling {{sig_name}} signal");
        rapidjson::Document doc;
        try {
            if (_{{sig_name | camelCase}}SignalCallbacks.size() > 0)
            {
                rapidjson::ParseResult ok = doc.Parse(msg.payload.c_str());
                if (!ok)
                {
                    _broker->Log(LOG_WARNING, "Could not JSON parse {{sig_name}} signal payload.");
                    return;
                }

                if (!doc.IsObject()) {
                    _broker->Log(LOG_WARNING, "Received payload is not an object");
                    return;
                }

                {%for arg in sig.arg_list%}
                {{arg.cpp_temp_type}} temp{{arg.name|UpperCamelCase}};
                { // Scoping
                    rapidjson::Value::ConstMemberIterator itr = doc.FindMember("{{arg.name}}");
                    if (itr != doc.MemberEnd() && itr->value.Is{{arg.cpp_rapidjson_type}}()) {
                        {%if arg.arg_type.name.lower() == 'primitive'%}
                        temp{{arg.name|UpperCamelCase}} = itr->value.Get{{arg.cpp_rapidjson_type}}();
                        {%elif arg.arg_type.name.lower() == 'enum'%}
                        temp{{arg.name|UpperCamelCase}} = static_cast<{{arg.cpp_data_type}}>(itr->value.Get{{arg.cpp_rapidjson_type}}());
                        {%elif arg.arg_type.name.lower() == 'datetime'%}
                        std::istringstream ss(itr->value.GetString());
                        std::tm tm = {};
                        ss >> std::get_time(&tm, "%Y-%m-%dT%H:%M:%S");
                        if (ss.fail()) {
                            throw std::runtime_error("Failed to parse datetime string");
                        }
                        temp{{arg.name|UpperCamelCase}} = std::chrono::system_clock::from_time_t(std::mktime(&tm));
                        {%elif arg.arg_type.name.lower() == 'duration'%}
                        temp{{arg.name|UpperCamelCase}} = stinger::utils::parseIsoDuration(itr->value.GetString());
                        {%elif arg.arg_type.name.lower() == 'binary'%}
                        temp{{arg.name|UpperCamelCase}} = stinger::utils::base64Decode(itr->value.GetString());
                        {%endif%}
                    } else {
                    {%-if arg.optional%}
                        temp{{arg.name|UpperCamelCase}} = std::nullopt;
                    {%else%}
                        throw std::runtime_error("Received payload for '{{sig_name}}' doesn't have required value/type");
                    {%endif%}
                    }
                }
                {%endfor%}{# for signal args #}
                std::lock_guard<std::mutex> lock(_{{sig_name | lowerCamelCase}}SignalCallbacksMutex);
                for (const auto& cb : _{{sig_name | lowerCamelCase}}SignalCallbacks)
                {
                    cb({%for arg in sig.arg_list%}temp{{arg.name|UpperCamelCase}}{%if not loop.last%}, {%endif%}{%endfor%});
                }
            }
        }
        catch (const std::exception&)
        {
            // We couldn't find an integer out of the string in the topic name,
            // so we are dropping the message completely. 
            // TODO: Log this failure
        }
    }
    {%-endfor%}{# for signals #}

    {%-for method_name, method in stinger.methods.items() %}
    {%if not loop.first%}else {%endif%}if (subscriptionId == _{{method_name | lowerCamelCase}}MethodSubscriptionId)
    {
        _broker->Log(LOG_DEBUG, "Matched topic for {{method_name}} response");
        _handle{{method_name|UpperCamelCase}}Response(topic, payload, mqttProps);
    }
    {%-endfor%}{# for methods #}

    {%-for prop_name, prop in stinger.properties.items() %}
    {%if not loop.first%}else {%endif%}if ((subscriptionId == _{{prop_name | lowerCamelCase}}PropertySubscriptionId) || (subscriptionId == noSubId && topic == (format("{{prop.value_topic}}") % _instanceId).str()))
    {
        _receive{{prop_name | UpperCamelCase}}PropertyUpdate(topic, payload, mqttProps.propertyVersion);
    }
    {%-endfor%}{# for properties #}
}


{%-for sig_name, sig in stinger.signals.items() %}
void {{stinger.cpp.client_class_name}}::register{{sig_name | UpperCamelCase}}Callback(const std::function<void({%for arg in sig.arg_list%}{{arg.cpp_temp_type}}{%if not loop.last%}, {%endif%}{%endfor%})>& cb)
{
    std::lock_guard<std::mutex> lock(_{{sig_name | lowerCamelCase}}SignalCallbacksMutex);
    _{{sig_name | lowerCamelCase}}SignalCallbacks.push_back(cb);
}
{%-endfor%}

{%for method_name, method in stinger.methods.items()%}
std::future<{{method.return_value_cpp_class}}> {{stinger.cpp.client_class_name}}::{{method_name | camelCase}}({%for arg in method.arg_list%}{{arg.cpp_temp_type}} {{arg.name|lowerCamelCase}}{%if not loop.last%}, {%endif%}{%endfor%})
{
    std::vector<std::byte> correlationId = generate_uuid_bytes();
    _pending{{method_name|UpperCamelCase}}MethodCalls[correlationId] = std::promise<{{method.return_value_cpp_class}}>();

    rapidjson::Document doc;
    doc.SetObject();

    {%for arg in method.arg_list%}
    {{ser.addToValue('doc', arg, 'doc.GetAllocator()') | indent(4)}}
    {%endfor%}
    rapidjson::StringBuffer buf;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buf);
    doc.Accept(writer);

    std::map<std::string, std::string> topicArgs;
    topicArgs["client_id"] = _broker->GetClientId();
    topicArgs["service_id"] = _instanceInfo.serviceId.value_or("error_service_id_not_found");
    topicArgs["interface_name"] = NAME;
    {%-for topic_param in config.topics.params %}
    topicArgs["{{topic_param}}"] = _instanceInfo.{{topic_param|lowerCamelCase}}.value_or("error_{{topic_param}}_not_found");
    {%-endfor%}

    auto responseTopic = stinger::utils::format("{{method.response_topic()}}", topicArgs);
    auto requestTopic = stinger::utils::format("{{method.request_topic()}}", topicArgs);
    auto msg = stinger::utils::MqttMessage::MethodRequest(requestTopic, buf.GetString(), correlationId, responseTopic);

    _broker->Publish(msg);

    return _pending{{method_name|UpperCamelCase}}MethodCalls[correlationId].get_future();
}

void {{stinger.cpp.client_class_name}}::_handle{{method_name|UpperCamelCase}}Response(
        const std::string& topic, 
        const std::string& payload, 
        const stinger::utils::MqttProperties& mqttProps) 
{
    _broker->Log(LOG_DEBUG, "In response handler for {{method_name}}");
    
    {%if method.return_value_type is not false%}
    rapidjson::Document doc;
    rapidjson::ParseResult ok = doc.Parse(payload.c_str());
    if (!ok)
    {
        //Log("Could not JSON parse {{method_name}} signal payload.");
        throw std::runtime_error(rapidjson::GetParseError_En(ok.Code()));
    }
    if (!doc.IsObject()) {
        throw std::runtime_error("Received payload for '{{method_name}}' response is not an object");
    }
    {%endif%}
    auto correlationId = mqttProps.correlationId.value_or(std::string());
    auto promiseItr = _pending{{method_name|UpperCamelCase}}MethodCalls.find(correlationId);
    if (promiseItr != _pending{{method_name|UpperCamelCase}}MethodCalls.end())
    {
        if (mqttProps.returnCode && (static_cast<stinger::error::MethodReturnCode>(*(mqttProps.returnCode)) != stinger::error::MethodReturnCode::SUCCESS))
        {
            // The method call failed, so set an exception on the promise.
            promiseItr->second.set_exception(createStingerException(static_cast<stinger::error::MethodReturnCode>(mqttProps.returnCode.value_or(static_cast<int>(stinger::error::MethodReturnCode::UNKNOWN_ERROR))), mqttProps.debugInfo.value_or("Exception returned via MQTT")));
            return;
        }

        // Found the promise for this correlation ID.
        {%if method.return_arg_list | length == 0 %}
        // Method doesn't have any return values.
        promiseItr->second.set_value();
        {%elif method.return_arg_list | length == 1%}
        // Method has a single return value.
        auto returnValue = {{method_name | UpperCamelCase}}ReturnValues::FromRapidJsonObject(doc).{{method.return_arg_list[0].name|lowerCamelCase}};
        promiseItr->second.set_value(returnValue);
        {%else%}
        // Method has multiple return values.
        auto returnValues = {{method_name | UpperCamelCase}}ReturnValues::FromRapidJsonObject(doc);
        promiseItr->second.set_value(returnValues);
        {%endif%}
    }

    _broker->Log(LOG_DEBUG, "End of response handler for {{method_name}}");
}
{%endfor%}{# end for each method #}
{%for prop_name, prop in stinger.properties.items()%}
void {{stinger.cpp.client_class_name}}::_receive{{prop_name | UpperCamelCase}}PropertyUpdate(const std::string& topic, const std::string& payload, std::optional<int> optPropertyVersion)
{
    rapidjson::Document doc;
    rapidjson::ParseResult ok = doc.Parse(payload.c_str());
    if (!ok)
    {
        //Log("Could not JSON parse {{prop_name}} property update payload.");
        throw std::runtime_error(rapidjson::GetParseError_En(ok.Code()));
    }

    if (!doc.IsObject()) {
        throw std::runtime_error("Received '{{prop_name}}' property update payload is not an object");
    }
    {{prop.name | UpperCamelCase}}Property tempValue;
    {{deser.deserialize('tempValue', prop.arg_list, 'doc') | indent(4)}}

    { // Scope lock
        std::lock_guard<std::mutex> lock(_{{prop_name | lowerCamelCase}}PropertyMutex);
        _{{prop_name | lowerCamelCase}}Property = tempValue;
        _last{{prop_name | UpperCamelCase}}PropertyVersion = optPropertyVersion ? *optPropertyVersion : -1;
    }
    // Notify all registered callbacks.
    { // Scope lock
        std::lock_guard<std::mutex> lock(_{{prop_name | lowerCamelCase}}PropertyCallbacksMutex);
        for (const auto& cb : _{{prop_name | lowerCamelCase}}PropertyCallbacks)
        {
            // Don't need a mutex since we're using tempValue.
            cb({%for arg in prop.arg_list %}tempValue.{{arg.name|lowerCamelCase}}{%if not loop.last%}, {%endif%}{%endfor%});
        }
    }
}

{{pr.get_property_definition(stinger.cpp.client_class_name, prop_name, prop)}}

{{pr.callback_registration_definition(stinger.cpp.client_class_name, prop_name, prop)}}

{% if not prop.read_only %}
std::future<bool> {{stinger.cpp.client_class_name}}::update{{prop_name | UpperCamelCase}}Property({{ar.methodParams(prop.arg_list)}}) const
{
    rapidjson::Document doc;
    doc.SetObject();
    {%for item in prop.arg_list %}
    {{ser.addToValue('doc', item, 'doc.GetAllocator()') | indent(4)}}
    {%endfor %}
    rapidjson::StringBuffer buf;
    rapidjson::Writer<rapidjson::StringBuffer> writer(buf);
    doc.Accept(writer);
    stinger::utils::MqttProperties mqttProps;
    return _broker->Publish("{{prop.update_topic}}", buf.GetString(), 1, false, mqttProps);

}
{%endif%}
{% endfor %} {# for properties #}

} // namespace {{stinger.name|snake_case}}
{%for ns in config.cpp.namespace|reverse%}
} // namespace {{ns}}
{%endfor-%}