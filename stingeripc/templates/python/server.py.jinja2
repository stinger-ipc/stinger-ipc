"""
DO NOT MODIFY THIS FILE. {# Unless you see this comment, in which case you are modifying the template. #} It is automatically generated and changes will be over-written
on the next generation.

This is the Server for the {{stinger.name}} interface.
"""

import json
import logging

logging.basicConfig(level=logging.DEBUG)

from typing import Callable, Dict, Any, Optional
from connection import BrokerConnection
from method_codes import *
import {{stinger.get_enum_module_name()}} as {{stinger.get_enum_module_alias()}}

{%macro method_type_annotation(method) %}Callable[[{%for arg in method.arg_list%}{{arg.python_type}}{%if not loop.last%}, {%endif%}{%endfor%}], {{method.return_value.python_type}}]{%endmacro%}

class MethodResponseBuilder:

    def __init__(self, request: Dict[str, Any]):
        self._response = {}
        if "correlationId" in request and isinstance(request["correlationId"], str):
            self.correlation_id(request["correlationId"])

    @property
    def response(self):
        return self._response

    def is_valid(self) -> bool:
        return "correlationId" in self._response and "result" in self._response

    def correlation_id(self, correlationId: str):
        self._response["correlationId"] = correlationId
        return self
    
    def result_code(self, result_code: MethodResultCode):
        self._response["result"] = result_code.value
        return self

    def debug_result_message(self, message: str):
        self._response["debugResultMessage"] = message
        return self

    def return_value(self, value_name: str, return_value):
        self._response[value_name] = return_value
        return self


class {{stinger.name}}Server(object):

    def __init__(self, connection: BrokerConnection):
        self._logger = logging.getLogger('{{stinger.name}}Server')
        self._logger.setLevel(logging.DEBUG)
        self._logger.debug("Initializing {{stinger.name}}Server")
        self._conn = connection
        self._conn.set_message_callback(self._receive_message)
        self._conn.set_last_will(topic="{{stinger.interface_info.0}}", payload=None, qos=1, retain=True)
        {%for p,v in stinger.params.items()-%}
        self._{{p}} = {{v.payload.initialValue}}
        self._conn.subscribe("{{topics.get_param_value(stinger.name, false, p)}}", self.set_{{p}})
        self.changed_value_callback_for_{{p}} = None
        self._publish_interface_info()
        {%endfor-%}
        {%-for method in stinger.methods.values()%}
        self._conn.subscribe("{{method.topic}}")
        {%endfor-%}
        {%for method_name, method in stinger.methods.items()-%}
        self._{{method_name|snake_case}}_method_handler: Optional[{{method_type_annotation(method)}}] = None
        {%endfor%}
    
    def _receive_message(self, topic: str, payload: str):
        self._logger.debug("Received message to %s", topic)
        {%if stinger.methods | length > 0 -%}
        {%for method_name, method in stinger.methods.items()-%}
        {%if not loop.first%}el{%endif%}if self._conn.is_topic_sub(topic, "{{method.topic}}"):
            try:
                payload_obj = json.loads(payload)
            except json.decoder.JSONDecodeError:
                self._logger.warning("Invalid JSON payload received at topic '%s'", topic)
            else:
                self._process_{{method_name | snake_case}}_call(topic, payload_obj)
        {%endfor%}
        {%-else%}pass{%-endif%}

    def _publish_interface_info(self):
        self._conn.publish("{{stinger.interface_info.0}}", '''{{stinger.interface_info.1 | tojson}}''', qos=1, retain=True)

    {%for sig_name, sig in stinger.signals.items()-%}
    def emit_{{sig_name}}(self, {%for arg in sig.arg_list%}{{arg.name}}: {{arg.python_type}}{%if not loop.last%}, {%endif%}{%endfor%}):
        {%for arg in sig.arg_list%}
        if not isinstance({{arg.name}}, {{arg.python_type}}):
            raise ValueError(f"The '{{arg.name}}' value must be {{arg.python_type}}.")
        {%-endfor%}
        
        payload = { {%-for arg in sig.arg_list%}
            {%if arg.arg_type.name.lower() == 'value'%}"{{arg.name}}": {{arg.python_type}}({{arg.name}}),{%endif-%}
            {%if arg.arg_type.name.lower() == 'enum'%}"{{arg.name}}": {{arg.python_type}}({{arg.name}}).value,{%endif%}{%endfor%}
        }
        self._conn.publish("{{sig.topic}}", json.dumps(payload), qos=1, retain=False)

    {%endfor%}

    {%for method_name, method in stinger.methods.items()%}
    def handle_{{method_name | snake_case}}(self, handler: {{method_type_annotation(method)}}):
        if self._{{method_name|snake_case}}_method_handler is None and handler is not None:
            self._{{method_name|snake_case}}_method_handler = handler
        else:
            raise Exception("Method handler already set")

    def _process_{{method_name | snake_case}}_call(self, topic, payload):
        if self._{{method_name|snake_case}}_method_handler is not None:
            response_builder = MethodResponseBuilder(payload)
            method_args = []
            {%for arg in method.arg_list -%}
            if "{{arg.name}}" in payload:
                if not isinstance(payload["{{arg.name}}"], {{arg.python_type}}):
                    self._logger.warning("The '{{arg.name}}' property in the payload to '%s' wasn't the correct type.  It should have been {{arg.python_type}}.", topic)
                    return
                else:
                    method_args.append(payload["{{arg.name}}"])
            else:
                self._logger.info("The '{{arg.name}}' property in the payload to '%s' wasn't present", topic)
            {%endfor%}
            try:
                return_value = self._{{method_name|snake_case}}_method_handler(*method_args)
                {%macro build_response(arg, var)%}
                {%-if arg.arg_type.name.lower() == 'value'%}
                response_builder.return_value("{{arg.name}}", {{var}})
                {%-elif arg.arg_type.name.lower() == 'enum'%}
                response_builder.return_value("{{arg.name}}", {{var}}.value)
                {%-endif%}
                {%-endmacro%}
                {%-if method.return_value.arg_type.name.lower() == 'struct'%}
                {%-for arg in method.return_value.members%}
                {{build_response(arg, "return_value."+arg.name)}}
                {%-endfor%}
                {%-else %}
                {{build_response(method.return_value, "return_value")}}
                {%-endif%}
            except Exception as e:
                self._logger.exception("Exception while handling {{method_name}}", exc_info=e)
                response_builder.result_code(MethodResultCode.SERVER_ERROR).debug_result_message(str(e))
            else:
                response_builder.result_code(MethodResultCode.SUCCESS)


            if response_builder.is_valid():
                response_topic = f"{{method.response_topic("{payload['clientId']}")}}"
                self._conn.publish(response_topic, json.dumps(response_builder.response), qos=1, retain=False)
    {%endfor%}

    {%for p,v in stinger.params.items()-%}
    {%-set args = payload(v['payload']) %}
    def set_{{p}}(self, {%for arg in args%}{{arg.name}}{%if not loop.last%}, {%endif%}{%endfor%}):
        changed = False
        {%for arg in payload(v['payload'])-%}
        if {{arg.name}} != self._{{p}}['{{arg.name}}']:
            changed = True
            self._{{p}}['{{arg.name}}'] = {{arg.name}}
        {%endfor-%}
        if changed:
            topic = "{{topics.get_param_value(stinger.name, false, p)}}"
            self._conn.publish(topic, self._{{p}}, 1, True)
            if self.changed_value_callback_for_{{p}} is not None:
                self.changed_value_callback_for_{{p}}({%for arg in args%}{{arg.name}}{%if not loop.last%}, {%endif%}{%endfor%})

    def get_{{p}}(self):
        {%if args | length > 1 -%}
        return self._{{p}}
        {%-else-%}
        return self._{{p}}[args[0].name]
        {%-endif%}
    {%endfor%}

if __name__ == '__main__':
    """
    This shows an example on how to run the code.  Ideally, your app should do something similar, but use the methods in
    a more meaningful way.
    """
    from time import sleep
    import signal
    {%set broker = stinger.get_example_broker()%}
    from connection import {{broker.class_name}}

    conn = {{broker.class_name}}({%if broker.hostname is none%}'localhost', 1883{%endif%})
    server = {{stinger.name}}Server(conn)

    {%for method_name, method in stinger.methods.items()%}
    @server.handle_{{method_name | snake_case}}
    def {{method_name | snake_case}}({%for arg in method.arg_list%}{{arg.name}}: {{arg.python_type}}{%if not loop.last%}, {%endif%}{%endfor%}) -> {{method.return_value.python_type}}:
        print(f"Running {{method_name | snake_case}}'({%for arg in method.arg_list %}{ {{-arg.name-}} }{%if not loop.last%}, {%endif%}{%endfor%})'")
        return {{method.return_value.get_random_example_value('python')}}
    {%endfor%}

    {%for sig_name, sig in stinger.signals.items()-%}
    server.emit_{{sig_name}}({%for arg in sig.arg_list%}{{arg.get_random_example_value()}}{%if not loop.last%}, {%endif%}{%endfor%})
    {%endfor%}
    sleep(4)
    {%for sig_name, sig in stinger.signals.items()-%}
    server.emit_{{sig_name}}({%for arg in sig.arg_list%}{{arg.name}}={{arg.get_random_example_value()}}{%if not loop.last%}, {%endif%}{%endfor%})
    {%endfor%}

    print("Ctrl-C will stop the program.")
    signal.pause()