/*
DO NOT MODIFY THIS FILE{# <-- Ignore this because you are editing the template file. #}.  It is automatically generated and changes will be over-written
on the next generation.

This is the Server for the {{stinger.name}} interface.
*/

extern crate paho_mqtt as mqtt;
use connection::{MessagePublisher, Connection, ReceivedMessage};

use futures::StreamExt;
use connection::Connection;
{%if stinger.methods | length > 0 %}use connection::payloads::MethodResultCode;{%endif%}


pub struct {{stinger.name | UpperCamelCase}}Server {
    {%for method_name, method in stinger.methods.items()-%}
    /// Pointer to a function to handle the {{method_name}} method request.
    method_handler_for_{{method_name|snake_case}}: Box<dyn FnMut({%for arg in method.arg_list%}{{arg.rust_type}}{%if not loop.last%}, {%endif%}{%endfor%})->Result<{{method.return_value.rust_type}}, MethodResultCode>>,
    {%endfor%}
    /// Temporarily holds the receiver for the MPSC channel.  The Receiver will be moved
    /// to a process loop when it is needed.  MQTT messages will be received with this.
    msg_streamer_rx: Option<mpsc::Receiver<ReceivedMessage>>,

    /// The Sender side of MQTT messages that are received from the broker.  This tx
    /// side is cloned for each subscription made.
    msg_streamer_tx: mpsc::Sender<ReceivedMessage>,

    /// Through this MessagePublisher object, we can publish messages to MQTT.
    msg_publisher: MessagePublisher,

    /// Copy of MQTT Client ID
    client_id: String,
}

impl {{stinger.name | UpperCamelCase}}Server {
    pub async fn new(mut connection: Connection) -> Self {
        let _ = connection.connect().await.expect("Could not connect to MQTT broker");

        //let interface_info = String::from(r#"{{stinger.interface_info.1 | tojson}}"#);
        //connection.publish("{{stinger.interface_info.0}}".to_string(), interface_info, 1).await;

        // Create a channel for messages to get from the Connection object to this {{stinger.name | UpperCamelCase }}Client object.
        // The Connection object uses a clone of the tx side of the channel.
        let (message_received_tx, message_received_rx) = mpsc::channel(64);

        let publisher = connection.get_publisher();

        // Subscribe to all the topics needed for method requests.
        {%for method_name, method in stinger.methods.items()-%}
        let subscription_id_{{method_name | snake_case}}_method_req = connection.subscribe("{{method.topic}}", message_received_tx.clone()).await;
        let subscription_id_{{method_name | snake_case}}_method_req = subscription_id_{{method_name | snake_case}}_method_req.unwrap_or_else(|_| -1);
        {%endfor%}

        // Create structure for subscription ids.
        let sub_ids = {{stinger.name | UpperCamelCase }}SubscriptionIds {
            {%for method_name, method in stinger.methods.items()-%}
            {{method_name | snake_case}}_method_req: subscription_id_{{method_name | snake_case}}_method_req,
            {%endfor%}
        };

        {{stinger.name | UpperCamelCase}}Server {
            {%for method_name, method in stinger.methods.items()-%}
            method_handler_for_{{method_name|snake_case}}: Box::new( |{%for arg in method.arg_list-%}_{{loop.index}}{%if not loop.last%}, {%endif%}{%endfor%}| { Err(MethodResultCode::ServerError) } ),
            {%endfor%}
            msg_streamer_rx: Some(message_received_rx),
            msg_streamer_tx: message_received_tx,
            msg_publisher: publisher,
            subscription_ids: sub_ids,
            client_id: connection.client_id.to_string(),
        }
    }

    {%for sig_name, sig in stinger.signals.items()-%}
    pub async fn emit_{{sig_name|snake_case}}(&mut self, {%for arg in sig.arg_list%}{{arg.name|snake_case}}: {{arg.rust_type}}{%if not loop.last%}, {%endif%}{%endfor%}) {
        let data = connection::payloads::{{sig_name|UpperCamelCase}}SignalPayload {
            {%for arg in sig.arg_list%}
            {{arg.name}}: {{arg.name|snake_case}},
            {%endfor%}
        };
        self.publisher.publish_simple("{{sig.topic}}".to_string(), data).await;
    }
    {%endfor%}

    {%for method_name, method in stinger.methods.items()-%}
    pub fn set_method_handler_for_{{method_name|snake_case}}(&mut self, cb: impl FnMut({%for arg in method.arg_list%}{{arg.rust_type}}{%if not loop.last%}, {%endif%}{%endfor%})->Result<{{method.return_value.rust_type}}, MethodResultCode> + 'static) {
        self.method_handler_for_{{method_name|snake_case}} = Box::new(cb);
    }
    {%endfor%}

    {%for method_name, method in stinger.methods.items()-%}
    async fn handle_{{method_name|snake_case}}_request(&mut self, msg: mqtt::Message) {
        let props = msg.properties();
        let opt_corr_id_bin: Option<Vec<u8>> = Some(msg_props.get_binary(mqtt::PropertyCode::CorrelationData));
        let opt_resp_topic = msg_props.get_string(mqtt::PropertyCode::ResponseTopic);

        let payload = serde_json::from_str::<{{method_name | UpperCamelCase}}RequestObject>(msg.payload_str().unwrap()).unwrap();

        // call the method handler
        let rv: {{method.return_value.rust_type}} = (self.method_handler_for_{{method_name|snake_case}})({%for arg in method.arg_list%}payload.{{arg.name | snake_case}}{%if not loop.last%}, {%endif%}{%endfor%});
        
        if let Some(resp_topic) = opt_resp_topic {
            self.publisher.publish_response_structure(resp_topic, &rv, opt_corr_id_bin).await.expect("Failed to publish response structure");
        } else {
            eprintln!("No response topic found in message properties.");
        }
    }
    {%endfor%}

     /// Starts the tasks that process messages received.
    pub async fn receive_loop(&mut self) -> Result<(), JoinError> {

        // Take ownership of the RX channel that receives MQTT messages.  This will be moved into the loop_task.
        let mut message_receiver = self.msg_streamer_rx.take().expect("msg_streamer_rx should be Some");

        let sub_ids = self.subscription_ids.clone();

        let loop_task = tokio::spawn(async move {
            while let Some(msg) = message_receiver.recv().await {
                {%-for method_name, method in stinger.methods.items()%}
                {%if not loop.first%}else {%endif%}if msg.subscription_id == sub_ids.{{method_name | snake_case}}_method_resp {
                    {{stinger.name | UpperCamelCase }}Client.handle_{{method_name|snake_case}}_request(msg.message).await;
                }
                {%-endfor%}
            }   
        });

        println!("Started client receive task");
        Ok(())
    }
}
