/*
DO NOT MODIFY THIS FILE{# <-- Ignore this because you are editing the template file. #}.  It is automatically generated and changes will be over-written
on the next generation.

This is the Server for the {{stinger.name}} interface.
*/

use futures::StreamExt;
use connection::Connection;
use json::object;

use paho_mqtt::topic_matcher::TopicMatcher;

pub struct {{stinger.name}}Server {
    connection: Connection,
    topic_matcher: TopicMatcher::<u32>,
}

impl {{stinger.name}}Server {
    pub fn new(mut connection: Connection) -> {{stinger.name}}Server {

        let interface_info = String::from(r#"{{stinger.interface_info.1 | tojson}}"#);
        connection.publish("{{stinger.interface_info.0}}".to_string(), interface_info, 1);

        let mut topic_matcher = TopicMatcher::<dyn FnMut(String, String)>::new();
        {%for method_name, method in stinger.signals.items()-%}
        topic_matcher.insert("{{method.topic}}", Self::handle_{{method_name|snake_case}}_request);
        {%endfor%}

        {{stinger.name}}Server{
            connection: connection,
            topic_matcher: topic_matcher,
        }
    }

    {%for sig_name, sig in stinger.signals.items()-%}
    pub fn emit_{{sig_name|snake_case}}(&mut self, {%for arg in sig.arg_list%}{{arg.name|snake_case}}: {{arg.rust_type}}{%if not loop.last%}, {%endif%}{%endfor%}) {
        let data = object!{ {%for arg in sig.arg_list%}
            {%-if arg.arg_type.name.lower() == 'value'%}
            {{arg.name}}: {{arg.name|snake_case}},
            {%elif arg.arg_type.name.lower() == 'enum'%}
            {{arg.name}}: {{arg.name|snake_case}} as u32,
            {%endif-%}
            {%endfor%}
        };
        let data_str = json::stringify(data);
        self.connection.publish("{{sig.topic}}".to_string(), data_str, 2);
    }
    {%endfor%}

    {%for method_name, method in stinger.signals.items()-%}
    fn handle_{{method_name|snake_case}}_request(_topic: String, _payload: String) {

    }
    {%endfor%}

    pub async fn process(&mut self) {
        while let Some(opt_msg) = self.connection.rx.next().await {
            if let Some(msg) = opt_msg {
                let payload_object = json::parse(&msg.payload_str()).unwrap();
                let topic = &msg.topic();
                if self.topic_matcher.has_match(topic) {
                    println!("Matches");
                }
            }
        }
    }
}
