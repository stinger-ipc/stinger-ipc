/*
DO NOT MODIFY THIS FILE{# <-- Ignore this because you are editing the template file. #}.  It is automatically generated and changes will be over-written
on the next generation.

This is the Client for the {{stinger.name}} interface.

LICENSE: This generated code is not subject to any license restrictions from the generator itself.
TODO: Get license text from stinger file
*/
use std::collections::{HashMap};
use std::fmt;
use std::sync::{Arc, RwLock};

use stinger_mqtt_trait::message::{MqttMessage, QoS};
use stinger_mqtt_trait::{Mqtt5PubSub, Mqtt5PubSubError};
use tokio::sync::{broadcast};
use tokio::task::JoinHandle;
#[allow(unused_imports)]
use tracing::{debug, info, warn, error};
use crate::interface::InterfaceInfo;
use crate::property::{ {{-stinger.name | UpperCamelCase}}InitialPropertyValuesBuilder, {{stinger.name | UpperCamelCase}}InitialPropertyValues};

#[derive(Debug)]
pub enum {{stinger.name|UpperCamelCase}}DiscoveryError {
    Subscribe(Mqtt5PubSubError),
}

impl fmt::Display for {{stinger.name|UpperCamelCase}}DiscoveryError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            {{stinger.name|UpperCamelCase}}DiscoveryError::Subscribe(err) => write!(f, "failed to subscribe for discovery: {err}"),
        }
    }
}

impl std::error::Error for {{stinger.name|UpperCamelCase}}DiscoveryError {}

impl From<Mqtt5PubSubError> for {{stinger.name|UpperCamelCase}}DiscoveryError {
    fn from(value: Mqtt5PubSubError) -> Self {
        {{stinger.name|UpperCamelCase}}DiscoveryError::Subscribe(value)
    }
}

struct ServiceDiscovery {
    interface_info: Option<InterfaceInfo>,
    properties: {{stinger.name | UpperCamelCase}}InitialPropertyValuesBuilder,
    fully_discovered: std::sync::atomic::AtomicBool,
}

impl Default for ServiceDiscovery {
    fn default() -> Self {
        Self {
            interface_info: None,
            properties: {{stinger.name | UpperCamelCase}}InitialPropertyValuesBuilder::default(),
        }
    }
}

struct DiscoveredService {
    interface_info: InterfaceInfo,
    properties: {{stinger.name | UpperCamelCase}}InitialPropertyValues,
}

impl ServiceDiscovery {
    /// Attempts to convert a ServiceDiscovery into a DiscoveredService
    pub fn to_discovered_service(&self) -> Option<DiscoveredService> {
        match (&self.interface_info, self.properties.build()) {
            (Some(info), Some(props)) => Some(DiscoveredService {
                interface_info: info.clone(),
                properties: props,
            }),
            _ => None,
        }
    }
}

#[cfg(feature = "metrics")]
pub struct {{stinger.name|UpperCamelCase}}DiscoveryMetrics {
    pub discovery_start_time: std::time::Instant,
    pub time_of_first_discovery: Option<std::time::Instant>,
    pub received_property_values: std::sync::atomic::AtomicU32,
}

#[cfg(feature = "metrics")]
impl Default for {{stinger.name|UpperCamelCase}}DiscoveryMetrics {
    fn default() -> Self {
        Self {
            discovery_start_time: std::time::Instant::now(),
            time_of_first_discovery: None,
            total_discovered_instances: std::sync::atomic::AtomicU32::new(0),
            total_instances_seen: std::sync::atomic::AtomicU32::new(0),
            received_property_values: std::sync::atomic::AtomicU32::new(0),
        }
    }
}

#[cfg(feature = "metrics")]
impl {{stinger.name|UpperCamelCase}}DiscoveryMetrics {
    /// Sets the time_of_first_discovery if it hasn't been set yet
    pub fn set_time_of_first_discovery(&mut self) {
        if self.time_of_first_discovery.is_none() {
            self.time_of_first_discovery = Some(std::time::Instant::now());
        }
    }

    /// Increments received_property_values by 1
    pub fn increment_received_property_values(&self) {
        self.received_property_values.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    }
}


pub struct {{stinger.name|UpperCamelCase}}Discovery {
    service_name: String,
    subscription_id: u32,
    property_subscription_id: u32,
    discovered_interfaces: Arc<RwLock<HashMap<String, ServiceDiscovery>>>,
    info_listener_handle: JoinHandle<()>,
    prop_listener_handle: JoinHandle<()>,
    notification_tx: broadcast::Sender<InterfaceInfo>,
    #[cfg(feature = "metrics")] pub metrics: Arc<Mutex<{{stinger.name|UpperCamelCase}}DiscoveryMetrics>>,
}

/// Event receiver for new interface discovery notifications
pub type {{stinger.name|UpperCamelCase}}DiscoveryReceiver = broadcast::Receiver<InterfaceInfo>;

impl {{stinger.name|UpperCamelCase}}Discovery {
    pub async fn new(
        connection: &mut impl Mqtt5PubSub,
    ) -> Result<Self, {{stinger.name|UpperCamelCase}}DiscoveryError> {

        let service_name = "{{stinger.name}}".to_string();
        let discovery_topic = format!("{{stinger.interface_info_topic}}", "+");

        let (info_tx, info_rx) = broadcast::channel::<MqttMessage>(32);
        debug!("Subscribing to discovery topic: {discovery_topic}");
        let subscription_id = connection
            .subscribe(discovery_topic, QoS::AtLeastOnce, info_tx.clone())
            .await
            .map_err({{stinger.name|UpperCamelCase}}DiscoveryError::from)?;

        let (prop_tx, prop_rx) = broadcast::channel::<MqttMessage>(32);
        let property_subscription_id = connection
            .subscribe(format!("{{stinger.property_base_topic}}+/value", ""), QoS::AtLeastOnce, prop_tx.clone())
            .await
            .map_err({{stinger.name|UpperCamelCase}}DiscoveryError::from)?;

        let discovered_interfaces = Arc::new(RwLock::new(HashMap::new()));

        // Clients can get a notification receiver by calling the subscribe() method.
        let (notification_tx, _notification_rx) = broadcast::channel::<InterfaceInfo>(32);

        let info_listener_handle = Self::spawn_listener(
            info_rx,
            discovered_interfaces.clone(),
            notification_tx.clone(),
        );

        let prop_listener_handle = Self::spawn_property_listener(
            prop_rx,
            discovered_interfaces.clone(),
            notification_tx.clone(),
        );

        Ok(Self {
            service_name,
            subscription_id,
            property_subscription_id,
            discovered_interfaces,
            info_listener_handle,
            prop_listener_handle,
            notification_tx,
            #[cfg(feature = "metrics")] metrics: Arc::new(Mutex::new({{stinger.name|UpperCamelCase}}DiscoveryMetrics::default())),
        })
    }

    pub fn service_name(&self) -> &str {
        &self.service_name
    }

    pub fn discovered_interfaces(&self) -> Vec<DiscoveredService> {
           let guard = self.discovered_interfaces.read().expect("interfaces poisoned");
           guard.values()
              .filter(|sd| sd.fully_discovered.load(std::sync::atomic::Ordering::Relaxed))
              .filter_map(|sd| sd.to_discovered_service())
              .collect()
    }

    pub async fn get_singleton_service(&self) -> DiscoveredService {
        // First check if we already have an interface
        {
            let guard = self
                .discovered_interfaces
                .read()
                .expect("interfaces poisoned");
            if let Some(entry) = guard.values().next() {
                if entry.interface_info.is_some() {
                    let prop_build_result = entry.properties.build();
                    if prop_build_result.is_ok() {
                        return DiscoveredService {
                            interface_info: entry.interface_info.clone().unwrap(),
                            properties: prop_build_result.unwrap(),
                        };
                    }
                }
            }
        }

        // No interfaces yet, wait for the first one to be discovered
        let mut receiver = self.notification_tx.subscribe();
        receiver
            .recv()
            .await
            .expect("notification channel closed")
    }

    pub fn subscribe(&self) -> {{stinger.name|UpperCamelCase}}DiscoveryReceiver {
        self.notification_tx.subscribe()
    }

    fn spawn_listener(
        mut message_rx: broadcast::Receiver<MqttMessage>,
        discovered_interfaces: Arc<RwLock<HashMap<String, InterfaceInfo>>>,
        notification_tx: broadcast::Sender<InterfaceInfo>,
    ) -> JoinHandle<()> {
        tokio::spawn(async move {
            debug!("Listening for discovery messages");
            while let Ok(message) = message_rx.recv().await {
                Self::handle_message(message, &discovered_interfaces, &notification_tx);
            }
        })
    }

    fn spawn_property_listener(
        mut message_rx: broadcast::Receiver<MqttMessage>,
        discovered_interfaces: Arc<RwLock<HashMap<String, InterfaceInfo>>>,
        notification_tx: broadcast::Sender<InterfaceInfo>,
        #[cfg(feature = "metrics")] metrics: Arc<Mutex<{{stinger.name|UpperCamelCase}}DiscoveryMetrics>>,
    ) -> JoinHandle<()> {
        tokio::spawn(async move {
            debug!("Listening for property value messages");
            while let Ok(message) = message_rx.recv().await {
                #[cfg(feature = "metrics")] {
                    let mut metrics_guard = metrics.lock().unwrap();
                    metrics_guard.increment_received_property_values();
                }

                // Parse property topic (format: service/{instance_id}/property/{property_name}/value)
                let topic_parts: Vec<&str> = message.topic.split('/').collect();
                if topic_parts.len() == 5 {
                    let instance_id = topic_parts[1];
                    let property_name = topic_parts[3];
                    
                    let mut interfaces_guard = discovered_interfaces
                        .write()
                        .expect("interfaces write lock poisoned");
                    
                    if let Some(service_discovery) = interfaces_guard.get_mut(instance_id) {
                        // Update the property value in the builder
                        match property_name {
                            {%for prop_name in stinger.properties.keys() %}
                            "{{prop_name}}" => {
                                service_discovery.properties.{{prop_name|snake_case}}.(&message.payload);
                            }
                            {%endfor%}
                            _ => {
                                // Ignore unknown properties
                            }
                        }
                        service_discovery.properties.set_property(property_name, &message.payload);
                        
                        // Check if this completes the discovery
                        if let Some(discovered) = service_discovery.to_discovered_service() {
                            service_discovery.fully_discovered.store(true, std::sync::atomic::Ordering::Relaxed);
                            let _ = notification_tx.send(discovered.interface_info);
                            #[cfg(feature = "metrics")] {
                                let mut metrics_guard = metrics.lock().unwrap();
                                metrics_guard.set_time_of_first_discovery();
                            }
                        }
                    }
                }
            }
        })
    }
    

    fn handle_message(
        message: MqttMessage,
        discovered_interfaces: &Arc<RwLock<HashMap<String, InterfaceInfo>>>,
        notification_tx: &broadcast::Sender<InterfaceInfo>,
    ) {
        if message.payload.is_empty() {
            info!("Service represented by {} is now offline", message.topic);
            // Parse instance_id from topic (format: full/{instance_id}/interface)
            let topic_parts: Vec<&str> = message.topic.split('/').collect();
            if topic_parts.len() >= 2 {
                let instance_id = topic_parts[topic_parts.len() - 2].to_string();
                let mut interfaces_guard = discovered_interfaces
                    .write()
                    .expect("interfaces write lock poisoned");
                interfaces_guard.remove(&instance_id);
                drop(interfaces_guard);
            }
        } else {
            let deserialized = serde_json::from_slice::<InterfaceInfo>(&message.payload);
            match deserialized {
                Ok(info) => {
                    info!("Discovered service instance: {:?}", info);
                    let mut interfaces_guard = discovered_interfaces
                        .write()
                        .expect("interfaces write lock poisoned");
                    let instance_id = info.instance.clone();
                    let is_new_instance = interfaces_guard.insert(instance_id.clone(), info.clone()).is_none();
                    drop(interfaces_guard);

                    // Send notification only for new interfaces
                    if is_new_instance {
                        let _ = notification_tx.send(info);
                    }
                },
                Err(err) => {
                    error!("Failed to deserialize InterfaceInfo from {}: {}", message.topic, err);
                }
            }
        }
    }
}


impl Drop for {{stinger.name|UpperCamelCase}}Discovery {
    fn drop(&mut self) {
        self.listener_handle.abort();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_message(topic: &str, instance: &str) -> MqttMessage {
        let info = InterfaceInfo {
            interface_name: "sample".into(),
            title: "Sample".into(),
            version: "1.0".into(),
            instance: instance.into(),
            connection_topic: format!("sample/{instance}"),
            timestamp: "2024-01-01T00:00:00Z".into(),
        };
        let payload = serde_json::to_vec(&info).expect("serialize");

        MqttMessage {
            topic: topic.into(),
            payload,
            qos: 1,
            subscription_id: 42,
            response_topic: None,
            content_type: None,
            correlation_data: None,
            user_properties: HashMap::new(),
        }
    }

    #[tokio::test]
    async fn collects_unique_instances_and_topics() {
        let interfaces = Arc::new(RwLock::new(HashMap::new()));
        let (notification_tx, mut notification_rx) = broadcast::channel::<InterfaceInfo>(32);

        {{stinger.name|UpperCamelCase}}Discovery::handle_message(
            sample_message("service/alpha/interface", "alpha"),
            &interfaces,
            &notification_tx,
        );
        {{stinger.name|UpperCamelCase}}Discovery::handle_message(
            sample_message("service/beta/interface", "beta"),
            &interfaces,
            &notification_tx,
        );
        {{stinger.name|UpperCamelCase}}Discovery::handle_message(
            sample_message("service/alpha/interface", "alpha"),
            &interfaces,
            &notification_tx,
        );

        let interfaces_guard = interfaces.read().unwrap();
        assert_eq!(interfaces_guard.len(), 2);
        assert!(interfaces_guard.contains_key("alpha"));
        assert!(interfaces_guard.contains_key("beta"));

        // Check that we received exactly 2 notifications (only for new interfaces)
        let info1 = notification_rx.try_recv().expect("should have first notification");
        assert_eq!(info1.instance, "alpha");
        let info2 = notification_rx.try_recv().expect("should have second notification");
        assert_eq!(info2.instance, "beta");
        assert!(notification_rx.try_recv().is_err(), "should not have third notification");
    }
}